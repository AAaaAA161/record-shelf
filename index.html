<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Deine Musiksammlung mit Tidal-Integration">
    <meta name="theme-color" content="#d4845f">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Record Shelf">
    <title>Record Shelf</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/icon-192.png">
    <!-- 
        Record Shelf v1.4.0 - GitHub Pages Edition
        Progressive Web App for GitHub Pages
        Features: IndexedDB storage, Storage Persistence API, Options page, Export/Import backups, cards layout, dropdown menu
        
        NEU in v1.4.0:
        - âš™ï¸ Einstellungen-Seite mit Kategorie-Sortierung
        - Drag & Drop: Hauptkategorien umsortieren
        - Persistierung der Kategorie-Reihenfolge in IndexedDB
        - Versionsnummer im Footer auf allen Seiten
        
        NEU in v1.3.2.3:
        - Mobile Polish: Random Alben kleiner (max 100px)
        - Mobile Polish: Akkordions kompakter (kleinere Schrift, weniger Padding)
        - Mobile Polish: Text-UmbrÃ¼che verhindert (nowrap)
        - Mobile Polish: AbstÃ¤nde reduziert (10px statt 16px)
        
        NEU in v1.3.2.2:
        - Mobile Layout Fix: Buttons horizontal aligned
        - Mobile Layout Fix: Random Alben gleich groÃŸ
        - Mobile Layout Fix: Album-Grid immer 2 Spalten
        
        NEU in v1.3.2.1:
        - Storage Persistence API (fragt um Erlaubnis, Daten dauerhaft zu speichern)
        - Hilft gegen automatisches LÃ¶schen in Brave & anderen Privacy-Browsern
        
        NEU in v1.3.2:
        - IndexedDB statt localStorage (robuster, persistenter)
        - Automatisches Laden aus IndexedDB
        - JSON Import fÃ¼llt IndexedDB automatisch
        
        WICHTIG: Du brauchst einen Last.fm API Key!
        1. Gehe zu: https://www.last.fm/api/account/create
        2. Erstelle einen kostenlosen Account
        3. Ersetze 'DEIN_LASTFM_API_KEY_HIER' im Code mit deinem Key
    -->
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
:root {
            --bg-primary: #1f2128;
            --bg-secondary: #2a2d3a;
            --bg-card: #363944;
            --bg-card-hover: #3f4350;
            --text-primary: #ffffff;
            --text-secondary: #9ca3bf;
            --accent: #d4845f;
            --accent-dark: #c07653;
            --border: #3a3f5f;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        #app {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        h1 {
            font-family: 'Pacifico', cursive;
            font-size: 3rem;
            font-weight: 400;
            text-align: center;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            letter-spacing: 1px;
            color: var(--text-primary);
        }

        .subtitle {
            font-family: 'Inter', sans-serif;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Upload Screen */
        .upload-container {
            text-align: center;
            padding: 40px 20px 80px;
            animation: fadeIn 0.6s ease-out;
        }

        /* Modern Cards Layout */
        .upload-cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 30px;
            padding: 40px 20px;
            max-width: 1200px;
            margin: 0 auto;
            animation: fadeIn 0.6s ease-out;
        }

        @media (max-width: 1000px) {
            .upload-cards-container {
                grid-template-columns: 1fr;
                max-width: 600px;
            }
        }

        .upload-card {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .upload-card:hover {
            border-color: var(--accent);
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .upload-card-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .upload-card-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .upload-card h2 {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .upload-card-header p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .backup-restore-area {
            text-align: center;
            padding: 30px 20px;
        }

        .backup-icon {
            font-size: 4rem;
            opacity: 0.5;
            margin-bottom: 20px;
        }

        .backup-restore-btn {
            background: linear-gradient(135deg, rgba(100, 150, 255, 0.2), rgba(100, 150, 255, 0.1));
            color: rgba(100, 150, 255, 1);
            border: 2px solid rgba(100, 150, 255, 0.3);
            padding: 16px 36px;
            font-size: 1.05rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 150, 255, 0.1);
        }

        .backup-restore-btn:hover {
            background: linear-gradient(135deg, rgba(100, 150, 255, 0.3), rgba(100, 150, 255, 0.2));
            border-color: rgba(100, 150, 255, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(100, 150, 255, 0.2);
        }

        .upload-area {
            background: var(--bg-card);
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 40px 30px;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .upload-area:hover, .upload-area.dragging {
            border-color: var(--accent);
            background: var(--bg-card-hover);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .upload-text {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .upload-hint {
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 20px;
        }

        .upload-btn {
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            padding: 14px 32px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow);
        }

        .upload-btn:hover {
            background: var(--accent-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .file-input {
            display: none;
        }

        .csv-example {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 20px;
            text-align: left;
        }

        .csv-example h3 {
            font-size: 0.95rem;
            margin-bottom: 12px;
            font-weight: 600;
            opacity: 0.8;
        }

        .csv-example code {
            display: block;
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 10px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.8;
            color: var(--accent);
            margin: 10px 0;
        }

        .csv-example p {
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        /* Stats */
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            opacity: 0.6;
        }

        .stat-item {
            background: transparent;
            padding: 0;
            text-align: center;
            transition: opacity 0.2s ease;
        }

        .stat-item:hover {
            opacity: 1;
        }

        .stat-number {
            display: inline;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-right: 4px;
        }

        .stat-label {
            display: inline;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 400;
        }

        /* Button Container */
        .button-container {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            flex-wrap: nowrap;
            padding: 0 10px;
        }

        @media (max-width: 768px) {
            .button-container {
                gap: 8px;
            }
            
            .reset-btn,
            .backup-dropdown-btn {
                padding: 12px 16px !important;
                font-size: 0.9rem !important;
                white-space: nowrap;
            }
        }

        /* Reset Button */
        .reset-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 14px 32px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .reset-btn:hover {
            background: var(--bg-card);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .export-btn, .import-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 14px 32px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .export-btn:hover {
            background: rgba(107, 207, 143, 0.1);
            border-color: rgba(107, 207, 143, 0.5);
            transform: translateY(-2px);
        }

        .import-btn:hover {
            background: rgba(100, 150, 255, 0.1);
            border-color: rgba(100, 150, 255, 0.5);
            transform: translateY(-2px);
        }

        /* Dropdown Menu for Backup */
        .backup-dropdown {
            position: relative;
            display: inline-block;
        }

        .backup-dropdown-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 14px 32px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .backup-dropdown-btn:hover {
            background: var(--bg-card);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .dropdown-arrow {
            font-size: 0.8rem;
            transition: transform 0.2s ease;
        }

        .backup-dropdown-btn:hover .dropdown-arrow {
            transform: translateY(2px);
        }

        .backup-dropdown-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 1000;
            overflow: hidden;
        }

        .backup-dropdown-menu.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .backup-dropdown-menu button {
            width: 100%;
            background: none;
            border: none;
            padding: 16px 20px;
            text-align: left;
            cursor: pointer;
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-primary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .backup-dropdown-menu button:last-of-type {
            border-bottom: none;
        }

        .backup-dropdown-menu button:hover {
            background: var(--bg-card-hover);
        }

        .menu-icon {
            font-size: 1.5rem;
            opacity: 0.8;
        }

        .menu-title {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 2px;
        }

        .menu-desc {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .menu-info {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.2);
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Settings Button */
        .settings-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 14px 32px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .settings-btn:hover {
            background: var(--bg-card);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        /* Settings Screen */
        .settings-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        .settings-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .settings-header h1 {
            font-family: 'Pacifico', cursive;
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .settings-section {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .settings-section h2 {
            font-size: 1.3rem;
            margin-bottom: 10px;
        }

        .settings-section p {
            color: var(--text-secondary);
            margin-bottom: 20px;
            font-size: 0.95rem;
        }

        .category-list {
            list-style: none;
            padding: 0;
        }

        .category-item {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 16px;
            cursor: move;
            user-select: none;
            transition: all 0.2s ease;
        }

        .category-item:hover {
            background: var(--bg-card-hover);
            transform: translateX(4px);
        }

        .category-item.dragging {
            opacity: 0.5;
        }

        .drag-handle {
            font-size: 1.5rem;
            color: var(--text-secondary);
            cursor: grab;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .category-item-content {
            flex: 1;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .settings-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .settings-actions button {
            padding: 14px 32px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .btn-primary {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            background: var(--accent-dark);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--bg-card);
            border-color: var(--accent);
        }

        @media (max-width: 768px) {
            .settings-btn {
                padding: 12px 16px;
                font-size: 0.9rem;
            }

            .settings-container {
                padding: 16px;
            }

            .settings-section {
                padding: 20px;
            }

            .category-item {
                padding: 12px 16px;
            }

            .category-item-content {
                font-size: 1rem;
            }
        }

        /* Random Albums Showcase */
        .random-albums-container {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 30px auto 40px;
            max-width: 600px;
            padding: 0 20px;
        }

        .random-album-item {
            flex: 0 0 calc(33.333% - 8px);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .random-album-cover {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }

        .random-album-title {
            margin-top: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .random-album-artist {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .random-albums-container {
                gap: 6px;
                padding: 0 16px;
                max-width: 350px;
            }

            .random-album-item {
                flex: 0 0 calc(33.333% - 4px);
                max-width: 100px;
            }

            .random-album-title {
                font-size: 0.7rem;
                margin-top: 4px;
            }

            .random-album-artist {
                font-size: 0.65rem;
            }
        }

        /* Main Category Sections */
        .main-category-section {
            margin-bottom: 40px;
        }

        .main-category-header {
            background: transparent;
            padding: 16px 0;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .main-category-title {
            font-family: 'Pacifico', cursive;
            font-size: 1.4rem;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .main-category-count {
            background: transparent;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
            opacity: 0.6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .shuffle-btn {
            background: var(--bg-secondary);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1.2rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .shuffle-btn:hover {
            background: var(--bg-card);
            transform: rotate(180deg);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .shuffle-btn:active {
            transform: rotate(180deg) scale(0.95);
        }

        .genre-shuffle-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 1rem;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .genre-shuffle-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(180deg);
            opacity: 1;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .genre-shuffle-btn:active {
            transform: rotate(180deg) scale(0.95);
        }

        .main-category-content {
            /* Always visible - no accordion behavior */
        }

        /* Genre Sections */
        .genre-section {
            margin-bottom: 16px;
        }

        .genre-header {
            background: var(--bg-secondary);
            padding: 16px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
        }

        .genre-header:hover {
            background: var(--bg-card);
            transform: translateY(-2px);
        }

        .genre-header.active {
            background: var(--bg-card);
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .genre-emoji {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .genre-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            font-weight: 400;
        }

        .genre-count {
            background: transparent;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
            opacity: 0.6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .genre-preview-covers {
            display: flex;
            gap: 6px;
        }

        .genre-cover-preview {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            object-fit: cover;
            border: 2px solid var(--bg-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            .genre-preview-covers {
                display: flex;
                gap: 4px;
            }
            
            /* Hide 3rd cover on mobile, show only 2 */
            .genre-cover-preview:nth-child(3) {
                display: none;
            }
            
            /* Make covers slightly smaller on mobile */
            .genre-cover-preview {
                width: 28px;
                height: 28px;
                border-radius: 4px;
            }
            
            .genre-emoji {
                font-size: 1.2rem;
            }
            
            .genre-title {
                font-size: 1.1rem;
            }
        }

        .genre-icon {
            transition: transform 0.3s ease;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .genre-header.active .genre-icon {
            transform: rotate(180deg);
        }

        .genre-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
        }

        .genre-content.active {
            max-height: 10000px;
        }

        /* Albums Grid */
        .albums-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            padding: 24px;
            background: var(--bg-secondary);
            border-bottom-left-radius: 14px;
            border-bottom-right-radius: 14px;
            box-shadow: var(--shadow);
        }

        @media (max-width: 768px) {
            .albums-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
                padding: 16px;
            }

            /* Compact Accordions on Mobile */
            .main-category-header {
                padding: 12px 0;
                margin-bottom: 12px;
            }

            .main-category-title {
                font-size: 1.2rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .genre-section {
                margin-bottom: 10px;
            }

            .genre-header {
                padding: 12px 16px;
            }

            .genre-emoji {
                font-size: 1.2rem;
            }

            .genre-title {
                font-size: 0.9rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                flex: 1;
                margin: 0 10px;
            }

            .genre-count {
                font-size: 0.65rem;
                padding: 2px 6px;
                white-space: nowrap;
            }
        }

        /* Album Cards */
        .album-card {
            background: var(--bg-card);
            border-radius: 14px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: var(--shadow);
            position: relative;
        }

        .album-card:hover {
            transform: translateY(-6px);
            box-shadow: var(--shadow-lg);
            background: var(--bg-card-hover);
        }

        .album-cover {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            display: block;
        }

        .album-info {
            padding: 16px;
        }

        .album-title {
            font-family: 'Inter', sans-serif;
            font-size: 0.95rem;
            font-weight: 400;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .album-artist {
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 400;
            color: var(--text-secondary);
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .album-genre {
            font-family: 'Inter', sans-serif;
            display: inline-block;
            background: rgba(212, 132, 95, 0.15);
            color: var(--accent);
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 400;
            border: 1px solid rgba(212, 132, 95, 0.3);
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 100px 20px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading p {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        /* Error */
        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Footer */
        .app-footer {
            text-align: center;
            padding: 30px 20px 20px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            opacity: 0.6;
            margin-top: 60px;
        }

        .app-footer a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .app-footer a:hover {
            color: var(--accent);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Record Shelf</h1>
            <p class="subtitle">Meine Musiksammlung mit intelligenter Genre-Organisation</p>
        </header>

        <div id="app"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script>
        // API calls are now proxied through Netlify Functions
        // No API keys in frontend code!
        
        class AlbumLibraryApp {
            constructor() {
                // Last.fm API Key - ERSETZE MIT DEINEM EIGENEN KEY!
                // Hol dir einen kostenlosen Key auf: https://www.last.fm/api/account/create
                this.LASTFM_API_KEY = 'DEIN_LASTFM_API_KEY_HIER';
                
                this.albums = [];
                this.genreCache = new Map();
                this.genreMapping = this.createGenreMapping();
                this.genreColors = this.createGenreColors();
                this.genreIcons = this.createGenreIcons();
                this.mainCategories = this.createMainCategories();
                
                // Default category order
                this.categoryOrder = [
                    'ðŸ¤˜ Metal',
                    'ðŸŽ¸ Rock & Alternative',
                    'ðŸ”® Experimental',
                    'ðŸŽ§ Electronic & Synth',
                    'ðŸŽ¤ Pop',
                    'ðŸŽµ Urban',
                    'ðŸŽº Traditional & Roots',
                    'ðŸŒ World'
                ];
            }

            createMainCategories() {
                return {
                    'ðŸ¤˜ Metal': {
                        genres: ['metal', 'heavy metal', 'death metal', 'black metal', 'thrash metal', 
                                'doom metal', 'progressive metal', 'power metal', 'metalcore', 'nu metal',
                                'breakcore', 'cybergrind', 'deathcore', 'grindcore', 'screamo',
                                'drone', 'drone metal'],
                        color: 'rgba(80, 80, 80, 0.7)',
                        order: 1
                    },
                    'ðŸŽ¸ Rock & Alternative': {
                        genres: ['rock', 'punk', 'alternative', 'alternative rock', 'indie', 'indie rock', 
                                'grunge', 'shoegaze', 'post-punk', 'post-rock', 'noise rock', 'lo-fi', 'emo',
                                'hamburger schule', 'post-hardcore', 'sludge', 'slowcore', 'riot grrrl'],
                        color: 'rgba(212, 132, 95, 0.5)',
                        order: 2
                    },
                    'ðŸ”® Experimental': {
                        genres: ['experimental', 'avant-garde', 'noise', 'sound art', 'psychedelic'],
                        color: 'rgba(120, 120, 130, 0.5)',
                        order: 3
                    },
                    'ðŸŽ§ Electronic & Synth': {
                        genres: ['electronic', 'synth-pop', 'synthpop', 'techno', 'house', 'ambient', 
                                'edm', 'electronica', 'idm', 'downtempo', 'trip-hop', 'drum and bass', 
                                'dubstep', 'trance', 'synthwave', 'electro', 'industrial', 'glitch', 'vaporwave',
                                'minimal synth', 'minimal', 'electroclash'],
                        color: 'rgba(120, 150, 180, 0.5)',
                        order: 4
                    },
                    'ðŸŽ¤ Pop': {
                        genres: ['pop', 'indie pop', 'dream pop', 'art pop', 'electropop', 'dance-pop', 
                                'pop rock', 'power pop', 'chamber pop', 'baroque pop', 'singer-songwriter',
                                'liedermacher'],
                        color: 'rgba(198, 120, 141, 0.5)',
                        order: 5
                    },
                    'ðŸŽµ Urban': {
                        genres: ['hip hop', 'r&b', 'rap', 'trap', 'soul', 'neo-soul',
                                'experimental hip hop', 'instrumental hip-hop'],
                        color: 'rgba(180, 140, 120, 0.5)',
                        order: 6
                    },
                    'ðŸŽº Traditional & Roots': {
                        genres: ['jazz', 'blues', 'folk', 'indie folk', 'country', 'classical', 'reggae', 'funk',
                                'acoustic', 'piano', 'trumpet'],
                        color: 'rgba(200, 160, 100, 0.5)',
                        order: 7
                    },
                    'ðŸŒ World': {
                        genres: ['world', 'afrobeat', 'latin', 'bossa nova', 'flamenco', 'throat singing',
                                'africa', 'balkan', 'first nations', 'germany'],
                        color: 'rgba(130, 150, 140, 0.5)',
                        order: 8
                    }
                };
            }

            getMainCategory(genre) {
                const lowerGenre = genre.toLowerCase();
                
                // Sort categories by order before checking
                const sortedCategories = Object.entries(this.mainCategories)
                    .sort((a, b) => (a[1].order || 999) - (b[1].order || 999));
                
                // Only use exact match - no substring matching
                // This prevents false matches like "alternative" matching with "experimental"
                for (const [category, data] of sortedCategories) {
                    if (data.genres.some(g => g === lowerGenre)) {
                        return category;
                    }
                }
                
                // Fallback: Smart keyword matching for common suffixes/prefixes
                // Only match if genre ENDS with or CONTAINS the keyword as a whole word
                const keywordMappings = {
                    'ðŸ¤˜ Metal': ['metal'],
                    'ðŸŽ¸ Rock & Alternative': ['rock', 'punk', 'core'], // hardcore, metalcore, etc.
                    'ðŸŽ§ Electronic & Synth': ['techno', 'house', 'trance', 'wave'],
                    'ðŸŽ¤ Pop': ['pop'],
                    'ðŸŽµ Urban': ['hop', 'rap', 'r&b'],
                    'ðŸŽº Traditional & Roots': ['jazz', 'blues', 'folk', 'country'],
                    'ðŸŒ World': ['world', 'latin', 'african']
                };
                
                for (const [category, keywords] of Object.entries(keywordMappings)) {
                    for (const keyword of keywords) {
                        // Check if genre ends with keyword or contains it as whole word
                        if (lowerGenre.endsWith(keyword) || 
                            lowerGenre.includes(' ' + keyword) || 
                            lowerGenre.includes(keyword + ' ')) {
                            return category;
                        }
                    }
                }
                
                return 'ðŸŽµ Other';
            }

            createGenreColors() {
                return {
                    'rock': 'rgba(212, 132, 95, 0.4)',
                    'pop': 'rgba(198, 120, 141, 0.4)',
                    'synth-pop': 'rgba(168, 120, 180, 0.4)',
                    'synthpop': 'rgba(168, 120, 180, 0.4)',
                    'electronic': 'rgba(120, 150, 180, 0.4)',
                    'hip hop': 'rgba(180, 140, 120, 0.4)',
                    'jazz': 'rgba(200, 160, 100, 0.4)',
                    'folk': 'rgba(140, 160, 120, 0.4)',
                    'r&b': 'rgba(190, 130, 110, 0.4)',
                    'punk': 'rgba(180, 100, 90, 0.4)',
                    'country': 'rgba(170, 140, 100, 0.4)',
                    'classical': 'rgba(150, 130, 160, 0.4)',
                    'reggae': 'rgba(160, 150, 90, 0.4)',
                    'blues': 'rgba(100, 130, 150, 0.4)',
                    'world': 'rgba(130, 150, 140, 0.4)',
                    'experimental': 'rgba(120, 120, 130, 0.4)',
                    'alternative': 'rgba(140, 150, 150, 0.4)',
                    'indie': 'rgba(150, 160, 140, 0.4)',
                    // All metal genres = dark warm
                    'metal': 'rgba(80, 80, 80, 0.6)',
                    'heavy metal': 'rgba(80, 80, 80, 0.6)',
                    'death metal': 'rgba(70, 70, 70, 0.6)',
                    'black metal': 'rgba(60, 60, 60, 0.6)',
                    'thrash metal': 'rgba(90, 80, 70, 0.6)',
                    'doom metal': 'rgba(75, 75, 75, 0.6)',
                    'progressive metal': 'rgba(85, 85, 85, 0.6)',
                    'power metal': 'rgba(90, 85, 80, 0.6)',
                    'metalcore': 'rgba(80, 75, 75, 0.6)',
                    'nu metal': 'rgba(85, 80, 75, 0.6)',
                    'default': 'rgba(212, 132, 95, 0.4)'
                };
            }

            createGenreIcons() {
                return {
                    'rock': 'ðŸŽ¸',
                    'pop': 'ðŸŽ¤',
                    'synth-pop': 'ðŸŽ¹',
                    'synthpop': 'ðŸŽ¹',
                    'electronic': 'ðŸŽ§',
                    'hip hop': 'ðŸŽ¤',
                    'jazz': 'ðŸŽº',
                    'folk': 'ðŸŽ»',
                    'r&b': 'ðŸŽµ',
                    'punk': 'âš¡',
                    'country': 'ðŸ¤ ',
                    'classical': 'ðŸŽ¼',
                    'reggae': 'ðŸŒ´',
                    'blues': 'ðŸŽ¸',
                    'world': 'ðŸŒ',
                    'experimental': 'ðŸ”®',
                    'metal': 'ðŸ¤˜',
                    'alternative': 'ðŸŽ¸',
                    'indie': 'ðŸ’¿',
                    'indie rock': 'ðŸŽ¸',
                    'indie folk': 'ðŸŽ»',
                    'shoegaze': 'ðŸŒ«ï¸',
                    'post-punk': 'âš¡',
                    'grunge': 'ðŸŽ¸',
                    'heavy metal': 'ðŸ¤˜',
                    'death metal': 'â˜ ï¸',
                    'black metal': 'ðŸ–¤',
                    'thrash metal': 'âš¡',
                    'default': 'ðŸŽµ'
                };
            }

            getGenreColor(genre) {
                const lowerGenre = genre.toLowerCase();
                return this.genreColors[lowerGenre] || this.genreColors['default'];
            }

            getGenreIcon(genre) {
                const lowerGenre = genre.toLowerCase();
                return this.genreIcons[lowerGenre] || this.genreIcons['default'];
            }

            createGenreMapping() {
                return {
                    // Rock and variants (excluding indie/alternative rock and post-rock - those stay separate)
                    'rock': ['rock', 'classic rock', 'hard rock', 'soft rock', 
                             'garage rock', 'psychedelic rock', 'progressive rock', 'art rock',
                             'folk rock', 'blues rock', 'southern rock', 'glam rock', 'arena rock'],
                    
                    // Pop
                    'pop': ['pop', 'indie pop', 'dream pop', 'art pop', 'electropop', 
                            'dance-pop', 'pop rock', 'power pop', 'chamber pop', 'baroque pop'],
                    
                    // Electronic
                    'electronic': ['electronic', 'techno', 'house', 'ambient', 'edm', 'electronica', 
                                   'idm', 'downtempo', 'trip-hop', 'drum and bass', 'dubstep', 'trance',
                                   'synthwave', 'electro', 'industrial', 'glitch'],
                    
                    // Hip Hop
                    'hip hop': ['hip hop', 'hip-hop', 'rap', 'trap', 'conscious hip hop', 'gangsta rap',
                                'east coast hip hop', 'west coast hip hop', 'underground hip hop'],
                    
                    // Jazz
                    'jazz': ['jazz', 'bebop', 'cool jazz', 'free jazz', 'hard bop', 'modal jazz',
                             'jazz fusion', 'smooth jazz', 'contemporary jazz', 'avant-garde jazz'],
                    
                    // Folk
                    'folk': ['folk', 'indie folk', 'contemporary folk', 'freak folk', 'neo-folk', 'anti-folk', 'americana'],
                    
                    // R&B and Soul
                    'r&b': ['r&b', 'rnb', 'soul', 'neo-soul', 'contemporary r&b', 'motown'],
                    
                    // Punk (excluding post-punk - that's more alternative)
                    'punk': ['punk', 'punk rock', 'hardcore punk', 'pop punk',
                             'ska punk', 'crust punk', 'anarcho-punk'],
                    
                    // Country
                    'country': ['country', 'country rock', 'alt-country', 'outlaw country'],
                    
                    // Classical
                    'classical': ['classical', 'baroque', 'romantic', 'contemporary classical',
                                  'minimalism', 'opera', 'orchestral'],
                    
                    // Reggae
                    'reggae': ['reggae', 'dub', 'dancehall', 'roots reggae', 'ska'],
                    
                    // Blues
                    'blues': ['blues', 'delta blues', 'chicago blues', 'electric blues'],
                    
                    // World
                    'world': ['world', 'world music', 'afrobeat', 'latin', 'bossa nova', 'flamenco'],
                    
                    // Experimental
                    'experimental': ['experimental', 'avant-garde', 'noise', 'sound art']
                    
                    // Metal genres kept separate: heavy metal, death metal, black metal, etc.
                    // Alternative/Indie genres kept separate: indie, indie rock, alternative rock, shoegaze, grunge, post-punk, etc.
                };
            }

            mapGenre(originalGenre) {
                if (!originalGenre) return 'Unknown';
                
                const lowerGenre = originalGenre.toLowerCase().trim();
                
                // Only use exact match - no substring matching
                // This prevents "post-punk" from being mapped to "punk"
                for (const [mainGenre, subGenres] of Object.entries(this.genreMapping)) {
                    if (subGenres.some(sub => sub === lowerGenre)) {
                        return mainGenre.charAt(0).toUpperCase() + mainGenre.slice(1);
                    }
                }
                
                // If no exact match found, return original but capitalize
                return originalGenre.charAt(0).toUpperCase() + originalGenre.slice(1);
            }

            async init() {
                // Request persistent storage (wichtig fÃ¼r Brave & Privacy-Browser)
                await this.requestPersistentStorage();
                
                this.showLoading('Lade gespeicherte Alben...');
                
                try {
                    // Try to load from IndexedDB
                    const savedAlbums = await this.loadFromIndexedDB();
                    
                    if (savedAlbums && savedAlbums.length > 0) {
                        console.log(`${savedAlbums.length} gespeicherte Alben aus IndexedDB gefunden`);
                        this.albums = savedAlbums;
                        
                        // Re-map genres in case the mapping has changed
                        this.albums.forEach(album => {
                            if (album.genre) {
                                const oldGenre = album.genre;
                                album.genre = this.mapGenre(oldGenre);
                                if (oldGenre !== album.genre) {
                                    console.log(`Genre aktualisiert fÃ¼r ${album.album}: ${oldGenre} â†’ ${album.genre}`);
                                }
                            }
                        });
                        
                        // Save updated genres back to IndexedDB
                        await this.saveToIndexedDB();
                        
                        this.renderAlbumsByGenre();
                    } else {
                        console.log('Keine gespeicherten Alben gefunden');
                        this.showUploadScreen();
                    }
                } catch (error) {
                    console.error('Fehler beim Laden:', error);
                    this.showUploadScreen();
                }
            }

            // IndexedDB Helper Methods
            async openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('RecordShelfDB', 1);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('albums')) {
                            db.createObjectStore('albums', { keyPath: 'id' });
                        }
                    };
                });
            }

            async loadFromIndexedDB() {
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['albums'], 'readonly');
                    const store = transaction.objectStore('albums');
                    const request = store.get('albumLibrary');
                    
                    return new Promise((resolve, reject) => {
                        request.onsuccess = () => {
                            if (request.result) {
                                console.log('âœ… Daten aus IndexedDB geladen');
                                // Load categoryOrder if available
                                if (request.result.categoryOrder) {
                                    this.categoryOrder = request.result.categoryOrder;
                                }
                                resolve(request.result.albums || null);
                            } else {
                                resolve(null);
                            }
                        };
                        request.onerror = () => {
                            console.error('Fehler beim Laden aus IndexedDB:', request.error);
                            reject(request.error);
                        };
                    });
                } catch (error) {
                    console.error('Fehler beim Ã–ffnen der IndexedDB:', error);
                    return null;
                }
            }

            async saveToIndexedDB() {
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['albums'], 'readwrite');
                    const store = transaction.objectStore('albums');
                    
                    const data = {
                        id: 'albumLibrary',
                        albums: this.albums,
                        categoryOrder: this.categoryOrder,
                        savedAt: new Date().toISOString()
                    };
                    
                    store.put(data);
                    
                    return new Promise((resolve, reject) => {
                        transaction.oncomplete = () => {
                            console.log('âœ… Daten in IndexedDB gespeichert');
                            resolve();
                        };
                        transaction.onerror = () => {
                            console.error('Fehler beim Speichern in IndexedDB:', transaction.error);
                            reject(transaction.error);
                        };
                    });
                } catch (error) {
                    console.error('Fehler beim Speichern in IndexedDB:', error);
                }
            }

            async clearIndexedDB() {
                try {
                    const db = await this.openDB();
                    const transaction = db.transaction(['albums'], 'readwrite');
                    const store = transaction.objectStore('albums');
                    store.delete('albumLibrary');
                    
                    return new Promise((resolve) => {
                        transaction.oncomplete = () => {
                            console.log('âœ… IndexedDB gelÃ¶scht');
                            resolve();
                        };
                    });
                } catch (error) {
                    console.error('Fehler beim LÃ¶schen der IndexedDB:', error);
                }
            }

            async requestPersistentStorage() {
                if (navigator.storage && navigator.storage.persist) {
                    try {
                        // Check if already granted
                        const isPersisted = await navigator.storage.persisted();
                        
                        if (isPersisted) {
                            console.log('âœ… Storage ist bereits persistent');
                            return true;
                        }
                        
                        // Request persistence
                        const granted = await navigator.storage.persist();
                        
                        if (granted) {
                            console.log('âœ… Persistent Storage aktiviert! Daten bleiben erhalten.');
                        } else {
                            console.log('âš ï¸ Persistent Storage nicht gewÃ¤hrt. Browser kÃ¶nnte Daten lÃ¶schen.');
                        }
                        
                        return granted;
                    } catch (error) {
                        console.error('Fehler bei Storage Persistence Request:', error);
                        return false;
                    }
                } else {
                    console.log('â„¹ï¸ Storage Persistence API nicht verfÃ¼gbar (Ã¤lterer Browser)');
                    return false;
                }
            }

            showUploadScreen() {
                document.getElementById('app').innerHTML = `
                    <div class="upload-cards-container">
                        <div class="upload-card">
                            <div class="upload-card-header">
                                <div class="upload-card-icon">ðŸ“</div>
                                <h2>Neue Sammlung</h2>
                                <p>CSV-Datei mit deiner Musiksammlung</p>
                            </div>
                            
                            <div class="upload-area" id="uploadArea">
                                <div class="upload-icon">ðŸ“</div>
                                <div class="upload-text">CSV-Datei hier ablegen</div>
                                <div class="upload-hint">oder klicken zum AuswÃ¤hlen</div>
                                <button class="upload-btn" id="uploadBtn">
                                    Datei auswÃ¤hlen
                                </button>
                                <input type="file" id="fileInput" class="file-input" accept=".csv" />
                            </div>
                            
                            <div class="csv-example">
                                <h3>CSV-Format:</h3>
                                <code>album,artist
Kind of Blue,Miles Davis
Abbey Road,The Beatles</code>
                                <p style="margin-top: 10px; font-size: 0.85rem; opacity: 0.7;">
                                    <strong>Optional:</strong> tidal_id Spalte fÃ¼r direktes Ã–ffnen
                                </p>
                            </div>
                        </div>

                        <div class="upload-card">
                            <div class="upload-card-header">
                                <div class="upload-card-icon">ðŸ“‚</div>
                                <h2>Backup wiederherstellen</h2>
                                <p>Lade eine gespeicherte JSON-Datei</p>
                            </div>
                            
                            <div class="backup-restore-area">
                                <div class="backup-icon">ðŸ“‚</div>
                                <p style="color: rgba(255,255,255,0.8); margin-bottom: 20px;">
                                    Stelle deine Sammlung aus einem Backup wieder her.
                                    <br><strong>Keine API-Calls</strong> â€“ instant laden!
                                </p>
                                <button class="backup-restore-btn" onclick="document.getElementById('import-file-upload').click()">
                                    ðŸ“‚ Backup-Datei wÃ¤hlen
                                </button>
                                <input type="file" id="import-file-upload" accept=".json" style="display: none;" onchange="app.importBackup(event)">
                                
                                <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                                    <p style="font-size: 0.85rem; opacity: 0.6; margin-bottom: 8px;">ðŸ’¡ Wo finde ich Backups?</p>
                                    <p style="font-size: 0.8rem; opacity: 0.5;">
                                        Backups werden nach jedem CSV-Import automatisch heruntergeladen.
                                        Format: <code style="font-size: 0.75rem;">record-shelf-backup-YYYY-MM-DD.json</code>
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="app-footer">
                        Record Shelf v1.4.0
                    </div>
                `;

                this.setupFileUpload();
            }

            setupFileUpload() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());

                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragging');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragging');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragging');
                    const file = e.dataTransfer.files[0];
                    if (file) this.handleFile(file);
                });

                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) this.handleFile(file);
                });
            }

            showSettingsScreen() {
                document.getElementById('app').innerHTML = `
                    <div class="settings-container">
                        <div class="settings-header">
                            <h1>âš™ï¸ Einstellungen</h1>
                            <p style="color: var(--text-secondary);">Passe Record Shelf an deine BedÃ¼rfnisse an</p>
                        </div>

                        <div class="settings-section">
                            <h2>Kategorie-Reihenfolge</h2>
                            <p>Ziehe die Kategorien um sie neu anzuordnen</p>
                            
                            <ul class="category-list" id="categoryList">
                                ${this.categoryOrder.map((cat, index) => `
                                    <li class="category-item" data-index="${index}" draggable="true">
                                        <span class="drag-handle">â˜°</span>
                                        <span class="category-item-content">${cat}</span>
                                    </li>
                                `).join('')}
                            </ul>

                            <div class="settings-actions">
                                <button class="btn-secondary" onclick="app.resetCategoryOrder()">
                                    ðŸ”„ Standard wiederherstellen
                                </button>
                                <button class="btn-primary" onclick="app.saveCategoryOrder()">
                                    ðŸ’¾ Speichern & ZurÃ¼ck
                                </button>
                            </div>
                        </div>

                        <div style="text-align: center; margin-top: 20px;">
                            <button class="btn-secondary" onclick="app.renderAlbumsByGenre()">
                                â† ZurÃ¼ck ohne Speichern
                            </button>
                        </div>

                        <div class="app-footer">
                            Record Shelf v1.4.0
                        </div>
                    </div>
                `;

                this.setupDragAndDrop();
            }

            setupDragAndDrop() {
                const list = document.getElementById('categoryList');
                const items = list.querySelectorAll('.category-item');
                let draggedElement = null;

                items.forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        draggedElement = item;
                        item.classList.add('dragging');
                    });

                    item.addEventListener('dragend', (e) => {
                        item.classList.remove('dragging');
                    });

                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        const afterElement = this.getDragAfterElement(list, e.clientY);
                        if (afterElement == null) {
                            list.appendChild(draggedElement);
                        } else {
                            list.insertBefore(draggedElement, afterElement);
                        }
                    });
                });
            }

            getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.category-item:not(.dragging)')];

                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;

                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            async saveCategoryOrder() {
                const list = document.getElementById('categoryList');
                const items = list.querySelectorAll('.category-item');
                
                // Update categoryOrder based on current DOM order
                this.categoryOrder = Array.from(items).map(item => 
                    item.querySelector('.category-item-content').textContent
                );

                // Save to IndexedDB
                await this.saveToIndexedDB();

                console.log('âœ… Kategorie-Reihenfolge gespeichert:', this.categoryOrder);

                // Go back to main view
                this.renderAlbumsByGenre();
            }

            resetCategoryOrder() {
                if (confirm('MÃ¶chtest du die Kategorie-Reihenfolge auf Standard zurÃ¼cksetzen?')) {
                    // Reset to default order
                    this.categoryOrder = [
                        'ðŸ¤˜ Metal',
                        'ðŸŽ¸ Rock & Alternative',
                        'ðŸ”® Experimental',
                        'ðŸŽ§ Electronic & Synth',
                        'ðŸŽ¤ Pop',
                        'ðŸŽµ Urban',
                        'ðŸŽº Traditional & Roots',
                        'ðŸŒ World'
                    ];

                    // Refresh the settings screen
                    this.showSettingsScreen();
                }
            }

            handleFile(file) {
                if (!file.name.endsWith('.csv')) {
                    this.showError('Bitte wÃ¤hle eine CSV-Datei aus.');
                    return;
                }

                this.showLoading();

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        this.processCSV(results.data);
                    },
                    error: (error) => {
                        this.showError('Fehler beim Lesen der CSV: ' + error.message);
                    }
                });
            }

            processCSV(data) {
                if (data.length === 0) {
                    this.showError('Die CSV-Datei ist leer.');
                    return;
                }

                // Check for required columns
                const firstRow = data[0];
                if (!firstRow.album || !firstRow.artist) {
                    this.showError('Die CSV muss die Spalten "album" und "artist" enthalten.');
                    return;
                }

                this.albums = data.filter(row => row.album && row.artist).map(row => {
                    const album = {
                        album: row.album,
                        artist: row.artist
                    };
                    
                    // Check for optional tidal_id or tidal_url column
                    if (row.tidal_id) {
                        album.tidalId = row.tidal_id;
                        console.log(`Tidal ID aus CSV fÃ¼r ${row.album}: ${row.tidal_id}`);
                    } else if (row.tidal_url) {
                        // Extract ID from URL like https://tidal.com/album/123456
                        const match = row.tidal_url.match(/album[\/:](\d+)/);
                        if (match) {
                            album.tidalId = match[1];
                            console.log(`Tidal ID aus CSV URL fÃ¼r ${row.album}: ${match[1]}`);
                        }
                    }
                    
                    return album;
                });
                
                console.log(`${this.albums.length} Alben geladen`);

                // Show loading state
                this.showLoading('Lade Genres und Cover...');
                
                // Load all data first, then render
                this.loadAllAlbumData();
            }

            async loadAllAlbumData() {
                try {
                    const total = this.albums.length;
                    const batchSize = 10; // Process 10 albums in parallel
                    const delayBetweenBatches = 100; // 100ms delay (Last.fm is tolerant)
                    
                    let processed = 0;
                    
                    // Process albums in batches
                    for (let i = 0; i < this.albums.length; i += batchSize) {
                        const batch = this.albums.slice(i, i + batchSize);
                        
                        // Process all albums in this batch in parallel
                        await Promise.all(batch.map(async (album) => {
                            // Load genre
                            const genre = await this.fetchGenreFromLastFM(album.artist);
                            album.genre = genre;
                            
                            // Load cover
                            const coverUrl = await this.fetchAlbumCover(album.album, album.artist);
                            album.coverUrl = coverUrl;
                            
                            // Tidal ID is already in CSV, no need to fetch
                            if (!album.tidalId) {
                                console.log(`Warnung: Keine Tidal ID fÃ¼r ${album.album} - ${album.artist}`);
                            }
                            
                            processed++;
                            
                            // Update progress
                            this.showLoading(`Lade Album-Daten von Last.fm...`, processed, total);
                            
                            console.log(`Geladen (${processed}/${total}): ${album.album} - ${album.artist}`);
                        }));
                        
                        // Small delay between batches to respect rate limits
                        if (i + batchSize < this.albums.length) {
                            await this.sleep(delayBetweenBatches);
                        }
                    }

                    console.log('Alle Daten geladen, rendere jetzt...');
                    
                    // Save to IndexedDB
                    await this.saveToIndexedDB();
                    
                    // Auto-create backup after successful import
                    this.autoExportBackup();
                    
                    // Now render grouped by genre
                    this.renderAlbumsByGenre();
                } catch (error) {
                    console.error('Fehler beim Laden der Daten:', error);
                    this.showError('Fehler beim Laden der Daten: ' + error.message);
                }
            }

            autoExportBackup() {
                try {
                    // Create backup object
                    const backup = {
                        version: '1.3',
                        exportDate: new Date().toISOString(),
                        albumCount: this.albums.length,
                        albums: this.albums
                    };

                    // Convert to JSON
                    const jsonString = JSON.stringify(backup, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    
                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    
                    // Filename with timestamp
                    const date = new Date().toISOString().split('T')[0];
                    a.download = `record-shelf-backup-${date}.json`;
                    
                    // Trigger download
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Save backup date
                    localStorage.setItem('lastBackupDate', new Date().toISOString());

                    console.log('âœ… Automatisches Backup erstellt');
                    
                } catch (error) {
                    console.error('Fehler beim automatischen Backup:', error);
                }
            }

            getLastBackupInfo(compact = false) {
                const lastBackup = localStorage.getItem('lastBackupDate');
                if (!lastBackup) {
                    return compact 
                        ? `<span style="opacity: 0.5;">Noch kein Backup</span>`
                        : `<div style="text-align: center; margin-bottom: 20px; color: rgba(255,255,255,0.5); font-size: 0.85rem;">
                            ðŸ’¡ Tipp: Erstelle regelmÃ¤ÃŸig Backups
                          </div>`;
                }

                const date = new Date(lastBackup);
                const now = new Date();
                const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));
                
                let timeText;
                if (diffDays === 0) {
                    timeText = 'heute';
                } else if (diffDays === 1) {
                    timeText = 'gestern';
                } else if (diffDays < 7) {
                    timeText = `vor ${diffDays} Tagen`;
                } else if (diffDays < 30) {
                    const weeks = Math.floor(diffDays / 7);
                    timeText = `vor ${weeks} Woche${weeks > 1 ? 'n' : ''}`;
                } else {
                    const months = Math.floor(diffDays / 30);
                    timeText = `vor ${months} Monat${months > 1 ? 'en' : ''}`;
                }

                const emoji = diffDays > 30 ? 'âš ï¸' : 'âœ…';
                
                return compact
                    ? `${emoji} Letztes: ${timeText}`
                    : `<div style="text-align: center; margin-bottom: 20px; color: rgba(255,255,255,0.6); font-size: 0.85rem;">
                        ${emoji} Letztes Backup: ${timeText}
                      </div>`;
            }

            toggleBackupMenu(event) {
                event.stopPropagation();
                const menu = document.getElementById('backupMenu');
                const isOpen = menu.classList.contains('show');
                
                if (isOpen) {
                    menu.classList.remove('show');
                } else {
                    menu.classList.add('show');
                    // Close on outside click
                    setTimeout(() => {
                        document.addEventListener('click', this.closeBackupMenu.bind(this), { once: true });
                    }, 100);
                }
            }

            closeBackupMenu() {
                const menu = document.getElementById('backupMenu');
                if (menu) {
                    menu.classList.remove('show');
                }
            }

            async fetchAlbumCover(albumName, artistName) {
                try {
                    // Direct Last.fm API call (no Netlify Function needed)
                    const url = `https://ws.audioscrobbler.com/2.0/?method=album.getinfo&api_key=${this.LASTFM_API_KEY}&artist=${encodeURIComponent(artistName)}&album=${encodeURIComponent(albumName)}&format=json`;
                    
                    const response = await fetch(url);
                    const data = await response.json();

                    if (data.album && data.album.image) {
                        const images = data.album.image;
                        const largeImage = images.find(img => img.size === 'extralarge') || 
                                         images.find(img => img.size === 'large') ||
                                         images[images.length - 1];
                        
                        if (largeImage && largeImage['#text']) {
                            return largeImage['#text'];
                        }
                    }
                    return null;
                } catch (error) {
                    console.error('Error loading cover:', error);
                    return null;
                }
            }

            async fetchTidalAlbumId(albumName, artistName) {
                // First, try direct Tidal search API
                try {
                    const searchQuery = encodeURIComponent(`${artistName} ${albumName}`);
                    const tidalResponse = await fetch(`https://api.tidal.com/v1/search/albums?query=${searchQuery}&limit=5&countryCode=US`);
                    
                    if (tidalResponse.ok) {
                        const tidalData = await tidalResponse.json();
                        if (tidalData.items && tidalData.items.length > 0) {
                            // Find best match
                            const bestMatch = tidalData.items.find(item => {
                                const matchAlbum = item.title.toLowerCase().includes(albumName.toLowerCase()) ||
                                                  albumName.toLowerCase().includes(item.title.toLowerCase());
                                const matchArtist = item.artist?.name?.toLowerCase().includes(artistName.toLowerCase()) ||
                                                   artistName.toLowerCase().includes(item.artist?.name?.toLowerCase());
                                return matchAlbum && matchArtist;
                            }) || tidalData.items[0]; // Fallback to first result
                            
                            if (bestMatch && bestMatch.id) {
                                console.log(`Tidal ID via Tidal API gefunden fÃ¼r ${albumName}: ${bestMatch.id}`);
                                return bestMatch.id.toString();
                            }
                        }
                    }
                } catch (error) {
                    console.log('Tidal API nicht verfÃ¼gbar, versuche MusicBrainz:', error.message);
                }

                // Fallback to MusicBrainz
                try {
                    const mbQuery = encodeURIComponent(`${albumName} AND artist:${artistName}`);
                    const mbResponse = await fetch(`https://musicbrainz.org/ws/2/release/?query=${mbQuery}&fmt=json&limit=5`);
                    const mbData = await mbResponse.json();

                    if (mbData.releases && mbData.releases.length > 0) {
                        // Check first few releases for external URLs
                        for (const release of mbData.releases.slice(0, 3)) {
                            if (release.id) {
                                const urlResponse = await fetch(`https://musicbrainz.org/ws/2/release/${release.id}?inc=url-rels&fmt=json`);
                                const urlData = await urlResponse.json();
                                
                                if (urlData.relations) {
                                    const tidalRelation = urlData.relations.find(rel => 
                                        rel.url && rel.url.resource && rel.url.resource.includes('tidal.com')
                                    );
                                    
                                    if (tidalRelation) {
                                        const match = tidalRelation.url.resource.match(/album[\/:](\d+)/);
                                        if (match) {
                                            console.log(`Tidal ID via MusicBrainz gefunden fÃ¼r ${albumName}: ${match[1]}`);
                                            return match[1];
                                        }
                                    }
                                }
                                
                                // Small delay between MusicBrainz requests (rate limiting)
                                await this.sleep(300);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error fetching Tidal ID from MusicBrainz:', error);
                }

                return null;
            }

            renderAlbumsByGenre() {
                // Group albums by genre
                const albumsByGenre = {};
                this.albums.forEach(album => {
                    const genre = album.genre || 'Unknown';
                    if (!albumsByGenre[genre]) {
                        albumsByGenre[genre] = [];
                    }
                    albumsByGenre[genre].push(album);
                });

                // Sort albums within each genre: first by artist, then by album
                Object.keys(albumsByGenre).forEach(genre => {
                    albumsByGenre[genre].sort((a, b) => {
                        const artistA = (a.artist || '').toLowerCase();
                        const artistB = (b.artist || '').toLowerCase();
                        
                        if (artistA < artistB) return -1;
                        if (artistA > artistB) return 1;
                        
                        const albumA = (a.album || '').toLowerCase();
                        const albumB = (b.album || '').toLowerCase();
                        
                        if (albumA < albumB) return -1;
                        if (albumA > albumB) return 1;
                        return 0;
                    });
                });

                // Group genres by main category
                const genresByCategory = {};
                Object.keys(albumsByGenre).forEach(genre => {
                    const mainCat = this.getMainCategory(genre);
                    if (!genresByCategory[mainCat]) {
                        genresByCategory[mainCat] = {};
                    }
                    genresByCategory[mainCat][genre] = albumsByGenre[genre];
                });

                // Sort main categories by user-defined order
                const sortedCategories = Object.keys(genresByCategory).sort((a, b) => {
                    const indexA = this.categoryOrder.indexOf(a);
                    const indexB = this.categoryOrder.indexOf(b);
                    // If not in categoryOrder, put at end
                    const orderA = indexA === -1 ? 999 : indexA;
                    const orderB = indexB === -1 ? 999 : indexB;
                    return orderA - orderB;
                });
                
                const uniqueArtists = new Set(this.albums.map(album => album.artist)).size;
                const totalGenres = Object.keys(albumsByGenre).length;

                // Select 3 random albums with covers
                const albumsWithCovers = this.albums.filter(album => album.coverUrl);
                const randomAlbums = [];
                if (albumsWithCovers.length >= 3) {
                    const shuffled = [...albumsWithCovers].sort(() => Math.random() - 0.5);
                    randomAlbums.push(...shuffled.slice(0, 3));
                }

                // Build random albums HTML
                let randomAlbumsHTML = '';
                if (randomAlbums.length === 3) {
                    randomAlbumsHTML = `
                        <div class="random-albums-container">
                            ${randomAlbums.map(album => {
                                // Build Tidal links same way as renderAlbumCard
                                let tidalDeepLink, tidalWebLink;
                                if (album.tidalId) {
                                    tidalDeepLink = `tidal://play/album/${album.tidalId}`;
                                    tidalWebLink = `https://listen.tidal.com/album/${album.tidalId}`;
                                } else {
                                    const searchQuery = encodeURIComponent(`${album.artist} ${album.album}`);
                                    tidalDeepLink = `tidal://search?q=${searchQuery}`;
                                    tidalWebLink = `https://listen.tidal.com/search?q=${searchQuery}`;
                                }
                                
                                return `
                                    <div class="random-album-item" 
                                         onclick="app.openInTidal('${tidalDeepLink.replace(/'/g, "\\'")}', '${tidalWebLink.replace(/'/g, "\\'")}', ${!!album.tidalId}, '${album.tidalId || ''}')"
                                         onmouseover="this.style.transform='translateY(-4px)'" 
                                         onmouseout="this.style.transform='translateY(0)'">
                                        <img src="${album.coverUrl}" 
                                             alt="${this.escapeHtml(album.album)}" 
                                             class="random-album-cover">
                                        <div class="random-album-title">${this.escapeHtml(album.album)}</div>
                                        <div class="random-album-artist">${this.escapeHtml(album.artist)}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                }

                let html = `
                    <div class="button-container">
                        <button class="reset-btn" onclick="app.loadNewCSV()">â† Neue CSV laden</button>
                        
                        <div class="backup-dropdown">
                            <button class="backup-dropdown-btn" onclick="app.toggleBackupMenu(event)">
                                <span>ðŸ’¾ Backup</span>
                                <span class="dropdown-arrow">â–¾</span>
                            </button>
                            <div class="backup-dropdown-menu" id="backupMenu">
                                <button onclick="app.exportBackup(); app.closeBackupMenu();">
                                    <span class="menu-icon">ðŸ’¾</span>
                                    <div>
                                        <div class="menu-title">Backup erstellen</div>
                                        <div class="menu-desc">JSON-Datei downloaden</div>
                                    </div>
                                </button>
                                <button onclick="document.getElementById('import-file').click(); app.closeBackupMenu();">
                                    <span class="menu-icon">ðŸ“‚</span>
                                    <div>
                                        <div class="menu-title">Backup laden</div>
                                        <div class="menu-desc">JSON-Datei importieren</div>
                                    </div>
                                </button>
                                <div class="menu-info">
                                    ${this.getLastBackupInfo(true)}
                                </div>
                            </div>
                        </div>
                        
                        <button class="settings-btn" onclick="app.showSettingsScreen()">âš™ï¸ Einstellungen</button>
                        
                        <input type="file" id="import-file" accept=".json" style="display: none;" onchange="app.importBackup(event)">
                    </div>
                    
                    ${randomAlbumsHTML}
                    
                    <div class="stats">
                        <div class="stat-item">
                            <span class="stat-number">${this.albums.length}</span>
                            <span class="stat-label">Alben</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">${uniqueArtists}</span>
                            <span class="stat-label">Musiker:innen</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">${totalGenres}</span>
                            <span class="stat-label">Genres</span>
                        </div>
                    </div>
                `;

                // Create main category sections
                let globalGenreIndex = 0;
                sortedCategories.forEach((mainCategory, catIndex) => {
                    const genres = genresByCategory[mainCategory];
                    const sortedGenres = Object.keys(genres).sort();
                    
                    // Count total albums in this category
                    const totalAlbums = sortedGenres.reduce((sum, genre) => sum + genres[genre].length, 0);
                    
                    const categoryColor = this.mainCategories[mainCategory]?.color || 'rgba(107, 207, 143, 0.4)';
                    
                    html += `
                        <div class="main-category-section">
                            <div class="main-category-header">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <span class="main-category-title">${mainCategory}</span>
                                    <span class="main-category-count">${totalAlbums}</span>
                                </div>
                                <button class="shuffle-btn" onclick="app.shuffleCategory('${mainCategory.replace(/'/g, "\\'")}')" title="ZufÃ¤lliges Album abspielen">
                                    â†»
                                </button>
                            </div>
                            <div class="main-category-content">
                    `;
                    
                    // Create genre accordions within category
                    sortedGenres.forEach((genre, genreIndex) => {
                        const albums = genres[genre];
                        const genreColor = this.getGenreColor(genre);
                        
                        // Get first 3 album covers for preview
                        const previewCovers = albums.slice(0, 3).map(album => {
                            if (album.coverUrl) {
                                return `<img src="${album.coverUrl}" alt="${this.escapeHtml(album.album)}" class="genre-cover-preview">`;
                            }
                            return '';
                        }).filter(Boolean).join('');
                        
                        // Show shuffle button only if more than 3 albums
                        const shuffleBtn = albums.length > 3 
                            ? `<button class="genre-shuffle-btn" onclick="event.stopPropagation(); app.shuffleGenre('${this.escapeHtml(genre).replace(/'/g, "\\'")}', ${globalGenreIndex})" title="ZufÃ¤lliges Album abspielen">â†»</button>`
                            : '';
                        
                        html += `
                            <div class="genre-section">
                                <div class="genre-header" 
                                     onclick="app.toggleGenre(${globalGenreIndex})" 
                                     style="border-left: 3px solid ${genreColor}">
                                    <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                                        <span class="genre-title">${this.escapeHtml(genre)}</span>
                                        <span class="genre-count">${albums.length}</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <div class="genre-preview-covers">
                                            ${previewCovers}
                                        </div>
                                        ${shuffleBtn}
                                        <span class="genre-icon">â–¼</span>
                                    </div>
                                </div>
                                <div class="genre-content" id="genre-${globalGenreIndex}">
                                    <div class="albums-grid">
                                        ${albums.map((album, index) => this.renderAlbumCard(album, index)).join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                        globalGenreIndex++;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });

                html += `
                    <div class="app-footer">
                        Record Shelf v1.4.0
                    </div>
                `;

                document.getElementById('app').innerHTML = html;
            }

            toggleGenre(index) {
                const headers = document.querySelectorAll('.genre-header');
                const contents = document.querySelectorAll('.genre-content');
                
                headers[index].classList.toggle('active');
                contents[index].classList.toggle('active');
            }

            shuffleCategory(mainCategory) {
                // Get all genres for this main category
                const categoryData = this.mainCategories[mainCategory];
                if (!categoryData) return;

                // Collect all albums from all genres in this category
                const categoryAlbums = this.albums.filter(album => {
                    const lowerGenre = (album.genre || '').toLowerCase();
                    return categoryData.genres.some(g => lowerGenre.includes(g) || g.includes(lowerGenre));
                });

                if (categoryAlbums.length === 0) {
                    alert('Keine Alben in dieser Kategorie gefunden.');
                    return;
                }

                // Pick random album
                const randomAlbum = categoryAlbums[Math.floor(Math.random() * categoryAlbums.length)];

                // Build Tidal links
                let tidalDeepLink, tidalWebLink;
                if (randomAlbum.tidalId) {
                    tidalDeepLink = `tidal://play/album/${randomAlbum.tidalId}`;
                    tidalWebLink = `https://listen.tidal.com/album/${randomAlbum.tidalId}`;
                } else {
                    const searchQuery = encodeURIComponent(`${randomAlbum.artist} ${randomAlbum.album}`);
                    tidalDeepLink = `tidal://search?q=${searchQuery}`;
                    tidalWebLink = `https://listen.tidal.com/search?q=${searchQuery}`;
                }

                // Open in Tidal
                this.openInTidal(tidalDeepLink, tidalWebLink, !!randomAlbum.tidalId, randomAlbum.tidalId || '');
            }

            shuffleGenre(genreName, genreIndex) {
                // Find all albums with this exact genre
                const genreAlbums = this.albums.filter(album => {
                    return album.genre && album.genre.toLowerCase() === genreName.toLowerCase();
                });

                if (genreAlbums.length === 0) {
                    alert('Keine Alben in diesem Genre gefunden.');
                    return;
                }

                // Pick random album
                const randomAlbum = genreAlbums[Math.floor(Math.random() * genreAlbums.length)];

                // Build Tidal links
                let tidalDeepLink, tidalWebLink;
                if (randomAlbum.tidalId) {
                    tidalDeepLink = `tidal://play/album/${randomAlbum.tidalId}`;
                    tidalWebLink = `https://listen.tidal.com/album/${randomAlbum.tidalId}`;
                } else {
                    const searchQuery = encodeURIComponent(`${randomAlbum.artist} ${randomAlbum.album}`);
                    tidalDeepLink = `tidal://search?q=${searchQuery}`;
                    tidalWebLink = `https://listen.tidal.com/search?q=${searchQuery}`;
                }

                // Open in Tidal
                this.openInTidal(tidalDeepLink, tidalWebLink, !!randomAlbum.tidalId, randomAlbum.tidalId || '');
            }

            async loadNewCSV() {
                if (confirm('MÃ¶chtest du wirklich eine neue CSV laden? Die aktuellen Daten werden Ã¼berschrieben.')) {
                    await this.clearIndexedDB();
                    this.albums = [];
                    this.showUploadScreen();
                }
            }

            exportBackup() {
                try {
                    // Create backup object
                    const backup = {
                        version: '1.3',
                        exportDate: new Date().toISOString(),
                        albumCount: this.albums.length,
                        albums: this.albums
                    };

                    // Convert to JSON
                    const jsonString = JSON.stringify(backup, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    
                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    
                    // Filename with timestamp
                    const date = new Date().toISOString().split('T')[0];
                    a.download = `record-shelf-backup-${date}.json`;
                    
                    // Trigger download
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Save backup date to localStorage
                    localStorage.setItem('lastBackupDate', new Date().toISOString());

                    console.log('âœ… Backup erstellt:', this.albums.length, 'Alben');
                    
                    // Show success message briefly
                    const originalText = event.target.textContent;
                    event.target.textContent = 'âœ… Gespeichert!';
                    setTimeout(() => {
                        event.target.textContent = originalText;
                    }, 2000);
                    
                } catch (error) {
                    console.error('Fehler beim Exportieren:', error);
                    alert('Fehler beim Erstellen des Backups: ' + error.message);
                }
            }

            importBackup(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        const backup = JSON.parse(e.target.result);
                        
                        // Validate backup structure
                        if (!backup.albums || !Array.isArray(backup.albums)) {
                            throw new Error('UngÃ¼ltiges Backup-Format');
                        }

                        // Confirm restore
                        const message = `Backup vom ${new Date(backup.exportDate).toLocaleDateString()}\n` +
                                      `${backup.albumCount} Alben\n\n` +
                                      `Aktuelle Daten Ã¼berschreiben?`;
                        
                        if (!confirm(message)) {
                            event.target.value = ''; // Reset file input
                            return;
                        }

                        // Restore albums
                        this.albums = backup.albums;
                        
                        // Save to IndexedDB
                        await this.saveToIndexedDB();
                        
                        // Re-render
                        this.renderAlbumsByGenre();
                        
                        console.log('âœ… Backup geladen und in IndexedDB gespeichert:', this.albums.length, 'Alben');
                        
                        // Reset file input
                        event.target.value = '';
                        
                    } catch (error) {
                        console.error('Fehler beim Importieren:', error);
                        alert('Fehler beim Laden des Backups: ' + error.message);
                        event.target.value = '';
                    }
                };
                
                reader.readAsText(file);
            }

            openInTidal(deepLink, webLink, hasTidalId, tidalId) {
                console.log('Ã–ffne Tidal:', deepLink);
                
                if (hasTidalId) {
                    // Try to detect if app opens
                    let appOpened = false;
                    
                    const handleVisibilityChange = () => {
                        if (document.hidden) {
                            appOpened = true;
                            console.log('App wurde geÃ¶ffnet');
                        }
                    };
                    
                    const handleBlur = () => {
                        appOpened = true;
                        console.log('App wurde geÃ¶ffnet (blur)');
                    };
                    
                    document.addEventListener('visibilitychange', handleVisibilityChange);
                    window.addEventListener('blur', handleBlur);
                    
                    // Try play deep link for mobile app
                    const playLink = `tidal://play/album/${tidalId}`;
                    window.location.href = playLink;
                    
                    // Check after 2 seconds if app opened
                    setTimeout(() => {
                        document.removeEventListener('visibilitychange', handleVisibilityChange);
                        window.removeEventListener('blur', handleBlur);
                        
                        if (!appOpened) {
                            console.log('App nicht installiert, Ã¶ffne Web Player');
                            window.open(webLink, '_blank');
                        } else {
                            console.log('App geÃ¶ffnet, kein Web Player nÃ¶tig');
                        }
                    }, 2000);
                } else {
                    // No Tidal ID - open search in both app and web
                    let appOpened = false;
                    
                    const handleVisibilityChange = () => {
                        if (document.hidden) appOpened = true;
                    };
                    
                    const handleBlur = () => {
                        appOpened = true;
                    };
                    
                    document.addEventListener('visibilitychange', handleVisibilityChange);
                    window.addEventListener('blur', handleBlur);
                    
                    window.location.href = deepLink;
                    
                    setTimeout(() => {
                        document.removeEventListener('visibilitychange', handleVisibilityChange);
                        window.removeEventListener('blur', handleBlur);
                        
                        if (!appOpened) {
                            window.open(webLink, '_blank');
                        }
                    }, 1500);
                }
            }

            renderAlbumCard(album, index) {
                const colors = [
                    'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                    'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                ];
                
                const coverStyle = album.coverUrl 
                    ? `src="${album.coverUrl}"` 
                    : `style="background: ${colors[index % colors.length]}"`;

                // Use Tidal ID if available, otherwise fall back to search
                let tidalDeepLink, tidalWebLink;
                if (album.tidalId) {
                    // Try play action first, fallback to regular album link
                    tidalDeepLink = `tidal://play/album/${album.tidalId}`;
                    tidalWebLink = `https://listen.tidal.com/album/${album.tidalId}`;
                } else {
                    const searchQuery = encodeURIComponent(`${album.artist} ${album.album}`);
                    tidalDeepLink = `tidal://search?q=${searchQuery}`;
                    tidalWebLink = `https://listen.tidal.com/search?q=${searchQuery}`;
                }

                return `
                    <div class="album-card" onclick="app.openInTidal('${tidalDeepLink.replace(/'/g, "\\'")}', '${tidalWebLink.replace(/'/g, "\\'")}', ${!!album.tidalId}, '${album.tidalId || ''}')">
                        <img class="album-cover" ${coverStyle} alt="${this.escapeHtml(album.album || 'Unknown Album')}" loading="lazy">
                        <div class="album-info">
                            <div class="album-title">${this.escapeHtml(album.album || 'Unknown Album')}</div>
                            <div class="album-artist">${this.escapeHtml(album.artist || 'Unknown Artist')}</div>
                            <span class="album-genre">${this.escapeHtml(album.genre || 'Unknown')}</span>
                        </div>
                    </div>
                `;
            }

            async fetchGenreFromLastFM(artist) {
                if (this.genreCache.has(artist)) {
                    return this.genreCache.get(artist);
                }

                try {
                    // Direct Last.fm API call (no Netlify Function needed)
                    const url = `https://ws.audioscrobbler.com/2.0/?method=artist.gettoptags&api_key=${this.LASTFM_API_KEY}&artist=${encodeURIComponent(artist)}&format=json`;
                    
                    const response = await fetch(url);
                    const data = await response.json();

                    let genre = 'Unknown';
                    if (data.toptags && data.toptags.tag && data.toptags.tag.length > 0) {
                        // Filter out non-genre tags (nationalities, decades, etc.)
                        const blacklist = [
                            // Nationalities
                            'french', 'german', 'british', 'american', 'canadian', 'australian',
                            'japanese', 'korean', 'swedish', 'norwegian', 'finnish', 'danish', 'kenya',
                            'italian', 'spanish', 'dutch', 'belgian', 'austrian', 'swiss',
                            'irish', 'scottish', 'welsh', 'icelandic', 'portuguese', 'austria', 'bayrisch', 'pakistan', 'peru',
                            'swedish', 'usa', 'ukrainian', 'ukranian',
                            // Cities/Places
                            'london', 'berlin', 'paris', 'new york', 'los angeles', 'tokyo',
                            'nyc', 'la', 'uk', 'usa', 'europe',
                            // Decades
                            '60s', '70s', '80s', '90s', '2000s', '2010s', '00s', '10s',
                            // Non-descriptive
                            'seen live', 'favorite', 'favorites', 'favourite', 'favourites',
                            'love', 'loved', 'awesome', 'beautiful', 'amazing',
                            // Genders
                            'female', 'male', 'female vocalists', 'male vocalists',
                            'female vocalist', 'male vocalist',
                            // Vague descriptors
                            'melancholic', 'melancholy', 'chill', 'atmospheric', 'cello', 'chillwave',
                            'cumbia', 'cybergrind', 'dischord', 'frenchcore', 'gospel', 'guitar',
                            'horrorcore', 'instrumental', 'mathcore', 'neocrust', 'outsider', 'touhou',
                            'bubblegum bass', 'political', 'new age', 'united states'
                        ];
                        
                        // Find first tag that's not in blacklist
                        const validTag = data.toptags.tag.find(tag => {
                            const tagName = tag.name.toLowerCase().trim();
                            return !blacklist.includes(tagName);
                        });
                        
                        if (validTag) {
                            const originalGenre = validTag.name;
                            genre = this.mapGenre(originalGenre);
                            console.log(`Genre fÃ¼r ${artist}: ${originalGenre} â†’ ${genre}`);
                        } else {
                            // Fallback to first tag if all are blacklisted
                            const originalGenre = data.toptags.tag[0].name;
                            genre = this.mapGenre(originalGenre);
                            console.log(`Genre fÃ¼r ${artist} (fallback): ${originalGenre} â†’ ${genre}`);
                        }
                    }

                    this.genreCache.set(artist, genre);
                    return genre;
                } catch (error) {
                    console.error('Error fetching genre:', error);
                    return 'Unknown';
                }
            }

            showLoading(message = 'Verarbeite CSV-Datei...', current = 0, total = 0) {
                const progressText = (current > 0 && total > 0) 
                    ? `<div style="margin-top: 10px; font-size: 1.2rem; font-weight: 600; color: var(--accent);">${current} / ${total}</div>`
                    : '';
                
                const progressBar = (current > 0 && total > 0)
                    ? `<div style="width: 100%; max-width: 300px; height: 4px; background: var(--bg-card); border-radius: 2px; margin: 20px auto 0; overflow: hidden;">
                        <div style="height: 100%; background: var(--accent); width: ${(current/total*100)}%; transition: width 0.3s ease;"></div>
                       </div>`
                    : '';
                
                document.getElementById('app').innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>${message}</p>
                        ${progressText}
                        ${progressBar}
                    </div>
                `;
            }

            showError(message) {
                document.getElementById('app').innerHTML = `
                    <div class="error">
                        <strong>Fehler:</strong> ${message}
                    </div>
                    <div class="upload-container">
                        <button class="upload-btn" onclick="app.init()">
                            Erneut versuchen
                        </button>
                    </div>
                `;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize app
        const app = new AlbumLibraryApp();
        app.init();

        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('[PWA] Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('[PWA] Service Worker registration failed:', error);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            console.log('[PWA] Install prompt available');
            
            // Show install button in app (if you want to add one later)
            // For now, users can install via browser menu
        });

        window.addEventListener('appinstalled', () => {
            console.log('[PWA] App was installed');
            deferredPrompt = null;
        });
    </script>
</body>
</html>
