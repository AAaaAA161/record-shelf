<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Deine Musiksammlung mit Tidal-Integration">
    <meta name="theme-color" content="#d4845f">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Record Shelf">
    <title>Record Shelf</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/icon-192.png">
    <!-- 
        Record Shelf v1.2 - PWA Edition
        Progressive Web App with Netlify Serverless Functions
        Features: Offline support, installable, secure API keys
    -->
    <!-- 
        Record Shelf v1.1
        Personal music library organizer with Tidal integration
        Features: Last.fm metadata, intelligent genre mapping, persistent storage
        
        v1.1 Changes:
        - Extended genre coverage (breakcore, vaporwave, throat singing, etc.)
        - Expanded blacklist filters for better genre accuracy
        - Added: emo, hamburger schule, riot grrrl, slowcore, funk, and more
    -->
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
:root {
            --bg-primary: #1f2128;
            --bg-secondary: #2a2d3a;
            --bg-card: #363944;
            --bg-card-hover: #3f4350;
            --text-primary: #ffffff;
            --text-secondary: #9ca3bf;
            --accent: #d4845f;
            --accent-dark: #c07653;
            --border: #3a3f5f;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            --shadow-lg: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        #app {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        h1 {
            font-family: 'Pacifico', cursive;
            font-size: 3rem;
            font-weight: 400;
            text-align: center;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            letter-spacing: 1px;
            color: var(--text-primary);
        }

        .subtitle {
            font-family: 'Inter', sans-serif;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Upload Screen */
        .upload-container {
            text-align: center;
            padding: 40px 20px 80px;
            animation: fadeIn 0.6s ease-out;
        }

        .upload-area {
            background: var(--bg-secondary);
            border: 2px dashed var(--border);
            border-radius: 20px;
            padding: 60px 40px;
            max-width: 600px;
            margin: 0 auto 40px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover, .upload-area.dragging {
            border-color: var(--accent);
            background: var(--bg-card);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3.5rem;
            margin-bottom: 20px;
            opacity: 0.6;
        }

        .upload-text {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .upload-hint {
            color: var(--text-secondary);
            font-size: 0.95rem;
            margin-bottom: 30px;
        }

        .upload-btn {
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            padding: 14px 32px;
            font-size: 1rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow);
        }

        .upload-btn:hover {
            background: var(--accent-dark);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .file-input {
            display: none;
        }

        .csv-example {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            margin: 0 auto;
            text-align: left;
        }

        .csv-example h3 {
            font-size: 1.1rem;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .csv-example code {
            display: block;
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 10px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.8;
            color: var(--accent);
            margin: 10px 0;
        }

        .csv-example p {
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        /* Stats */
        .stats {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 40px;
            opacity: 0.6;
        }

        .stat-item {
            background: transparent;
            padding: 0;
            text-align: center;
            transition: opacity 0.2s ease;
        }

        .stat-item:hover {
            opacity: 1;
        }

        .stat-number {
            display: inline;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-right: 4px;
        }

        .stat-label {
            display: inline;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 400;
        }

        /* Reset Button */
        .reset-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 12px 24px;
            font-size: 0.95rem;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 30px;
        }

        .reset-btn:hover {
            background: var(--bg-card);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        /* Main Category Sections */
        .main-category-section {
            margin-bottom: 40px;
        }

        .main-category-header {
            background: transparent;
            padding: 16px 0;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .main-category-title {
            font-family: 'Pacifico', cursive;
            font-size: 1.4rem;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .main-category-count {
            background: transparent;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
            opacity: 0.6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .shuffle-btn {
            background: var(--bg-secondary);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1.2rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .shuffle-btn:hover {
            background: var(--bg-card);
            transform: rotate(180deg);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .shuffle-btn:active {
            transform: rotate(180deg) scale(0.95);
        }

        .genre-shuffle-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 1rem;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .genre-shuffle-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: rotate(180deg);
            opacity: 1;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .genre-shuffle-btn:active {
            transform: rotate(180deg) scale(0.95);
        }

        .main-category-content {
            /* Always visible - no accordion behavior */
        }

        /* Genre Sections */
        .genre-section {
            margin-bottom: 16px;
        }

        .genre-header {
            background: var(--bg-secondary);
            padding: 16px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
        }

        .genre-header:hover {
            background: var(--bg-card);
            transform: translateY(-2px);
        }

        .genre-header.active {
            background: var(--bg-card);
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .genre-emoji {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .genre-title {
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            font-weight: 400;
        }

        .genre-count {
            background: transparent;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
            opacity: 0.6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .genre-preview-covers {
            display: flex;
            gap: 6px;
        }

        .genre-cover-preview {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            object-fit: cover;
            border: 2px solid var(--bg-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            .genre-preview-covers {
                display: flex;
                gap: 4px;
            }
            
            /* Hide 3rd cover on mobile, show only 2 */
            .genre-cover-preview:nth-child(3) {
                display: none;
            }
            
            /* Make covers slightly smaller on mobile */
            .genre-cover-preview {
                width: 28px;
                height: 28px;
                border-radius: 4px;
            }
            
            .genre-emoji {
                font-size: 1.2rem;
            }
            
            .genre-title {
                font-size: 1.1rem;
            }
        }

        .genre-icon {
            transition: transform 0.3s ease;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .genre-header.active .genre-icon {
            transform: rotate(180deg);
        }

        .genre-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease;
        }

        .genre-content.active {
            max-height: 10000px;
        }

        /* Albums Grid */
        .albums-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            padding: 24px;
            background: var(--bg-secondary);
            border-bottom-left-radius: 14px;
            border-bottom-right-radius: 14px;
            box-shadow: var(--shadow);
        }

        @media (max-width: 768px) {
            .albums-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 16px;
                padding: 16px;
            }
        }

        /* Album Cards */
        .album-card {
            background: var(--bg-card);
            border-radius: 14px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: var(--shadow);
            position: relative;
        }

        .album-card:hover {
            transform: translateY(-6px);
            box-shadow: var(--shadow-lg);
            background: var(--bg-card-hover);
        }

        .album-cover {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            display: block;
        }

        .album-info {
            padding: 16px;
        }

        .album-title {
            font-family: 'Inter', sans-serif;
            font-size: 0.95rem;
            font-weight: 400;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .album-artist {
            font-family: 'Inter', sans-serif;
            font-size: 0.85rem;
            font-weight: 400;
            color: var(--text-secondary);
            margin-bottom: 8px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .album-genre {
            font-family: 'Inter', sans-serif;
            display: inline-block;
            background: rgba(212, 132, 95, 0.15);
            color: var(--accent);
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 400;
            border: 1px solid rgba(212, 132, 95, 0.3);
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 100px 20px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading p {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        /* Error */
        .error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Album Library</h1>
            <p class="subtitle">Deine Musiksammlung</p>
        </header>

        <div id="app"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script>
        // API calls are now proxied through Netlify Functions
        // No API keys in frontend code!
        
        class AlbumLibraryApp {
            constructor() {
                this.albums = [];
                this.genreCache = new Map();
                this.genreMapping = this.createGenreMapping();
                this.genreColors = this.createGenreColors();
                this.genreIcons = this.createGenreIcons();
                this.mainCategories = this.createMainCategories();
            }

            createMainCategories() {
                return {
                    'ü§ò Metal': {
                        genres: ['metal', 'heavy metal', 'death metal', 'black metal', 'thrash metal', 
                                'doom metal', 'progressive metal', 'power metal', 'metalcore', 'nu metal',
                                'breakcore', 'cybergrind', 'deathcore', 'grindcore', 'screamo',
                                'drone', 'drone metal'],
                        color: 'rgba(80, 80, 80, 0.7)',
                        order: 1
                    },
                    'üé∏ Rock & Alternative': {
                        genres: ['rock', 'punk', 'alternative', 'alternative rock', 'indie', 'indie rock', 
                                'grunge', 'shoegaze', 'post-punk', 'post-rock', 'noise rock', 'lo-fi', 'emo',
                                'hamburger schule', 'post-hardcore', 'sludge', 'slowcore', 'riot grrrl'],
                        color: 'rgba(212, 132, 95, 0.5)',
                        order: 2
                    },
                    'üîÆ Experimental': {
                        genres: ['experimental', 'avant-garde', 'noise', 'sound art', 'psychedelic'],
                        color: 'rgba(120, 120, 130, 0.5)',
                        order: 3
                    },
                    'üéß Electronic & Synth': {
                        genres: ['electronic', 'synth-pop', 'synthpop', 'techno', 'house', 'ambient', 
                                'edm', 'electronica', 'idm', 'downtempo', 'trip-hop', 'drum and bass', 
                                'dubstep', 'trance', 'synthwave', 'electro', 'industrial', 'glitch', 'vaporwave',
                                'minimal synth', 'minimal', 'electroclash'],
                        color: 'rgba(120, 150, 180, 0.5)',
                        order: 4
                    },
                    'üé§ Pop': {
                        genres: ['pop', 'indie pop', 'dream pop', 'art pop', 'electropop', 'dance-pop', 
                                'pop rock', 'power pop', 'chamber pop', 'baroque pop', 'singer-songwriter',
                                'liedermacher'],
                        color: 'rgba(198, 120, 141, 0.5)',
                        order: 5
                    },
                    'üéµ Urban': {
                        genres: ['hip hop', 'r&b', 'rap', 'trap', 'soul', 'neo-soul',
                                'experimental hip hop', 'instrumental hip-hop'],
                        color: 'rgba(180, 140, 120, 0.5)',
                        order: 6
                    },
                    'üé∫ Traditional & Roots': {
                        genres: ['jazz', 'blues', 'folk', 'indie folk', 'country', 'classical', 'reggae', 'funk',
                                'acoustic', 'piano', 'trumpet'],
                        color: 'rgba(200, 160, 100, 0.5)',
                        order: 7
                    },
                    'üåç World': {
                        genres: ['world', 'afrobeat', 'latin', 'bossa nova', 'flamenco', 'throat singing',
                                'africa', 'balkan', 'first nations', 'germany'],
                        color: 'rgba(130, 150, 140, 0.5)',
                        order: 8
                    }
                };
            }

            getMainCategory(genre) {
                const lowerGenre = genre.toLowerCase();
                
                // Sort categories by order before checking
                const sortedCategories = Object.entries(this.mainCategories)
                    .sort((a, b) => (a[1].order || 999) - (b[1].order || 999));
                
                // Only use exact match - no substring matching
                // This prevents false matches like "alternative" matching with "experimental"
                for (const [category, data] of sortedCategories) {
                    if (data.genres.some(g => g === lowerGenre)) {
                        return category;
                    }
                }
                
                // Fallback: Smart keyword matching for common suffixes/prefixes
                // Only match if genre ENDS with or CONTAINS the keyword as a whole word
                const keywordMappings = {
                    'ü§ò Metal': ['metal'],
                    'üé∏ Rock & Alternative': ['rock', 'punk', 'core'], // hardcore, metalcore, etc.
                    'üéß Electronic & Synth': ['techno', 'house', 'trance', 'wave'],
                    'üé§ Pop': ['pop'],
                    'üéµ Urban': ['hop', 'rap', 'r&b'],
                    'üé∫ Traditional & Roots': ['jazz', 'blues', 'folk', 'country'],
                    'üåç World': ['world', 'latin', 'african']
                };
                
                for (const [category, keywords] of Object.entries(keywordMappings)) {
                    for (const keyword of keywords) {
                        // Check if genre ends with keyword or contains it as whole word
                        if (lowerGenre.endsWith(keyword) || 
                            lowerGenre.includes(' ' + keyword) || 
                            lowerGenre.includes(keyword + ' ')) {
                            return category;
                        }
                    }
                }
                
                return 'üéµ Other';
            }

            createGenreColors() {
                return {
                    'rock': 'rgba(212, 132, 95, 0.4)',
                    'pop': 'rgba(198, 120, 141, 0.4)',
                    'synth-pop': 'rgba(168, 120, 180, 0.4)',
                    'synthpop': 'rgba(168, 120, 180, 0.4)',
                    'electronic': 'rgba(120, 150, 180, 0.4)',
                    'hip hop': 'rgba(180, 140, 120, 0.4)',
                    'jazz': 'rgba(200, 160, 100, 0.4)',
                    'folk': 'rgba(140, 160, 120, 0.4)',
                    'r&b': 'rgba(190, 130, 110, 0.4)',
                    'punk': 'rgba(180, 100, 90, 0.4)',
                    'country': 'rgba(170, 140, 100, 0.4)',
                    'classical': 'rgba(150, 130, 160, 0.4)',
                    'reggae': 'rgba(160, 150, 90, 0.4)',
                    'blues': 'rgba(100, 130, 150, 0.4)',
                    'world': 'rgba(130, 150, 140, 0.4)',
                    'experimental': 'rgba(120, 120, 130, 0.4)',
                    'alternative': 'rgba(140, 150, 150, 0.4)',
                    'indie': 'rgba(150, 160, 140, 0.4)',
                    // All metal genres = dark warm
                    'metal': 'rgba(80, 80, 80, 0.6)',
                    'heavy metal': 'rgba(80, 80, 80, 0.6)',
                    'death metal': 'rgba(70, 70, 70, 0.6)',
                    'black metal': 'rgba(60, 60, 60, 0.6)',
                    'thrash metal': 'rgba(90, 80, 70, 0.6)',
                    'doom metal': 'rgba(75, 75, 75, 0.6)',
                    'progressive metal': 'rgba(85, 85, 85, 0.6)',
                    'power metal': 'rgba(90, 85, 80, 0.6)',
                    'metalcore': 'rgba(80, 75, 75, 0.6)',
                    'nu metal': 'rgba(85, 80, 75, 0.6)',
                    'default': 'rgba(212, 132, 95, 0.4)'
                };
            }

            createGenreIcons() {
                return {
                    'rock': 'üé∏',
                    'pop': 'üé§',
                    'synth-pop': 'üéπ',
                    'synthpop': 'üéπ',
                    'electronic': 'üéß',
                    'hip hop': 'üé§',
                    'jazz': 'üé∫',
                    'folk': 'üéª',
                    'r&b': 'üéµ',
                    'punk': '‚ö°',
                    'country': 'ü§†',
                    'classical': 'üéº',
                    'reggae': 'üå¥',
                    'blues': 'üé∏',
                    'world': 'üåç',
                    'experimental': 'üîÆ',
                    'metal': 'ü§ò',
                    'alternative': 'üé∏',
                    'indie': 'üíø',
                    'indie rock': 'üé∏',
                    'indie folk': 'üéª',
                    'shoegaze': 'üå´Ô∏è',
                    'post-punk': '‚ö°',
                    'grunge': 'üé∏',
                    'heavy metal': 'ü§ò',
                    'death metal': '‚ò†Ô∏è',
                    'black metal': 'üñ§',
                    'thrash metal': '‚ö°',
                    'default': 'üéµ'
                };
            }

            getGenreColor(genre) {
                const lowerGenre = genre.toLowerCase();
                return this.genreColors[lowerGenre] || this.genreColors['default'];
            }

            getGenreIcon(genre) {
                const lowerGenre = genre.toLowerCase();
                return this.genreIcons[lowerGenre] || this.genreIcons['default'];
            }

            createGenreMapping() {
                return {
                    // Rock and variants (excluding indie/alternative rock and post-rock - those stay separate)
                    'rock': ['rock', 'classic rock', 'hard rock', 'soft rock', 
                             'garage rock', 'psychedelic rock', 'progressive rock', 'art rock',
                             'folk rock', 'blues rock', 'southern rock', 'glam rock', 'arena rock'],
                    
                    // Pop
                    'pop': ['pop', 'indie pop', 'dream pop', 'art pop', 'electropop', 
                            'dance-pop', 'pop rock', 'power pop', 'chamber pop', 'baroque pop'],
                    
                    // Electronic
                    'electronic': ['electronic', 'techno', 'house', 'ambient', 'edm', 'electronica', 
                                   'idm', 'downtempo', 'trip-hop', 'drum and bass', 'dubstep', 'trance',
                                   'synthwave', 'electro', 'industrial', 'glitch'],
                    
                    // Hip Hop
                    'hip hop': ['hip hop', 'hip-hop', 'rap', 'trap', 'conscious hip hop', 'gangsta rap',
                                'east coast hip hop', 'west coast hip hop', 'underground hip hop'],
                    
                    // Jazz
                    'jazz': ['jazz', 'bebop', 'cool jazz', 'free jazz', 'hard bop', 'modal jazz',
                             'jazz fusion', 'smooth jazz', 'contemporary jazz', 'avant-garde jazz'],
                    
                    // Folk
                    'folk': ['folk', 'indie folk', 'contemporary folk', 'freak folk', 'neo-folk', 'anti-folk', 'americana'],
                    
                    // R&B and Soul
                    'r&b': ['r&b', 'rnb', 'soul', 'neo-soul', 'contemporary r&b', 'motown'],
                    
                    // Punk (excluding post-punk - that's more alternative)
                    'punk': ['punk', 'punk rock', 'hardcore punk', 'pop punk',
                             'ska punk', 'crust punk', 'anarcho-punk'],
                    
                    // Country
                    'country': ['country', 'country rock', 'alt-country', 'outlaw country'],
                    
                    // Classical
                    'classical': ['classical', 'baroque', 'romantic', 'contemporary classical',
                                  'minimalism', 'opera', 'orchestral'],
                    
                    // Reggae
                    'reggae': ['reggae', 'dub', 'dancehall', 'roots reggae', 'ska'],
                    
                    // Blues
                    'blues': ['blues', 'delta blues', 'chicago blues', 'electric blues'],
                    
                    // World
                    'world': ['world', 'world music', 'afrobeat', 'latin', 'bossa nova', 'flamenco'],
                    
                    // Experimental
                    'experimental': ['experimental', 'avant-garde', 'noise', 'sound art']
                    
                    // Metal genres kept separate: heavy metal, death metal, black metal, etc.
                    // Alternative/Indie genres kept separate: indie, indie rock, alternative rock, shoegaze, grunge, post-punk, etc.
                };
            }

            mapGenre(originalGenre) {
                if (!originalGenre) return 'Unknown';
                
                const lowerGenre = originalGenre.toLowerCase().trim();
                
                // Only use exact match - no substring matching
                // This prevents "post-punk" from being mapped to "punk"
                for (const [mainGenre, subGenres] of Object.entries(this.genreMapping)) {
                    if (subGenres.some(sub => sub === lowerGenre)) {
                        return mainGenre.charAt(0).toUpperCase() + mainGenre.slice(1);
                    }
                }
                
                // If no exact match found, return original but capitalize
                return originalGenre.charAt(0).toUpperCase() + originalGenre.slice(1);
            }

            init() {
                // Check if we have saved albums
                const savedAlbums = this.loadFromStorage();
                
                if (savedAlbums && savedAlbums.length > 0) {
                    console.log(`${savedAlbums.length} gespeicherte Alben gefunden`);
                    this.albums = savedAlbums;
                    
                    // Re-map genres in case the mapping has changed
                    this.albums.forEach(album => {
                        if (album.genre) {
                            const oldGenre = album.genre;
                            album.genre = this.mapGenre(oldGenre);
                            if (oldGenre !== album.genre) {
                                console.log(`Genre aktualisiert f√ºr ${album.album}: ${oldGenre} ‚Üí ${album.genre}`);
                            }
                        }
                    });
                    
                    // Save updated genres
                    this.saveToStorage();
                    
                    this.renderAlbumsByGenre();
                } else {
                    this.showUploadScreen();
                }
            }

            loadFromStorage() {
                try {
                    const stored = localStorage.getItem('albumLibrary');
                    if (stored) {
                        return JSON.parse(stored);
                    }
                } catch (error) {
                    console.error('Fehler beim Laden aus localStorage:', error);
                }
                return null;
            }

            saveToStorage() {
                try {
                    localStorage.setItem('albumLibrary', JSON.stringify(this.albums));
                    console.log('Alben im localStorage gespeichert');
                } catch (error) {
                    console.error('Fehler beim Speichern in localStorage:', error);
                }
            }

            clearStorage() {
                localStorage.removeItem('albumLibrary');
                console.log('localStorage gel√∂scht');
            }

            showUploadScreen() {
                document.getElementById('app').innerHTML = `
                    <h1>Record Shelf</h1>
                    <p class="subtitle">Meine Musiksammlung mit intelligenter Genre-Organisation</p>
                    
                    <div class="upload-container">
                        <div class="upload-area" id="uploadArea">
                            <div class="upload-icon">üìÅ</div>
                            <div class="upload-text">CSV-Datei hier ablegen</div>
                            <div class="upload-hint">oder klicken zum Ausw√§hlen</div>
                            <button class="upload-btn" id="uploadBtn">
                                Datei ausw√§hlen
                            </button>
                            <input type="file" id="fileInput" class="file-input" accept=".csv" />
                        </div>

                        <div class="csv-example">
                            <h3>CSV-Format Beispiel:</h3>
                            <code>album,artist
Kind of Blue,Miles Davis
Abbey Road,The Beatles
The Dark Side of the Moon,Pink Floyd</code>
                            <p style="margin-top: 15px; font-size: 0.9rem;">
                                <strong>Optional:</strong> Du kannst auch eine Spalte "tidal_id" oder "tidal_url" hinzuf√ºgen f√ºr direktes Album-√ñffnen in Tidal.
                            </p>
                            <code style="margin-top: 10px;">album,artist,tidal_id
Kind of Blue,Miles Davis,251380836
Abbey Road,The Beatles,77640617</code>
                            <p style="margin-top: 15px; font-size: 0.85rem; color: var(--accent); border-left: 3px solid var(--accent); padding-left: 10px;">
                                üí° <strong>Tipp:</strong> Auf Mobilger√§ten mit installierter Tidal App funktioniert das automatische Abspielen am besten!
                            </p>
                        </div>
                    </div>
                `;

                this.setupFileUpload();
            }

            setupFileUpload() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());

                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragging');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragging');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragging');
                    const file = e.dataTransfer.files[0];
                    if (file) this.handleFile(file);
                });

                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) this.handleFile(file);
                });
            }

            handleFile(file) {
                if (!file.name.endsWith('.csv')) {
                    this.showError('Bitte w√§hle eine CSV-Datei aus.');
                    return;
                }

                this.showLoading();

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        this.processCSV(results.data);
                    },
                    error: (error) => {
                        this.showError('Fehler beim Lesen der CSV: ' + error.message);
                    }
                });
            }

            processCSV(data) {
                if (data.length === 0) {
                    this.showError('Die CSV-Datei ist leer.');
                    return;
                }

                // Check for required columns
                const firstRow = data[0];
                if (!firstRow.album || !firstRow.artist) {
                    this.showError('Die CSV muss die Spalten "album" und "artist" enthalten.');
                    return;
                }

                this.albums = data.filter(row => row.album && row.artist).map(row => {
                    const album = {
                        album: row.album,
                        artist: row.artist
                    };
                    
                    // Check for optional tidal_id or tidal_url column
                    if (row.tidal_id) {
                        album.tidalId = row.tidal_id;
                        console.log(`Tidal ID aus CSV f√ºr ${row.album}: ${row.tidal_id}`);
                    } else if (row.tidal_url) {
                        // Extract ID from URL like https://tidal.com/album/123456
                        const match = row.tidal_url.match(/album[\/:](\d+)/);
                        if (match) {
                            album.tidalId = match[1];
                            console.log(`Tidal ID aus CSV URL f√ºr ${row.album}: ${match[1]}`);
                        }
                    }
                    
                    return album;
                });
                
                console.log(`${this.albums.length} Alben geladen`);

                // Show loading state
                this.showLoading('Lade Genres und Cover...');
                
                // Load all data first, then render
                this.loadAllAlbumData();
            }

            async loadAllAlbumData() {
                try {
                    const total = this.albums.length;
                    const batchSize = 10; // Process 10 albums in parallel
                    const delayBetweenBatches = 100; // 100ms delay (Last.fm is tolerant)
                    
                    let processed = 0;
                    
                    // Process albums in batches
                    for (let i = 0; i < this.albums.length; i += batchSize) {
                        const batch = this.albums.slice(i, i + batchSize);
                        
                        // Process all albums in this batch in parallel
                        await Promise.all(batch.map(async (album) => {
                            // Load genre
                            const genre = await this.fetchGenreFromLastFM(album.artist);
                            album.genre = genre;
                            
                            // Load cover
                            const coverUrl = await this.fetchAlbumCover(album.album, album.artist);
                            album.coverUrl = coverUrl;
                            
                            // Tidal ID is already in CSV, no need to fetch
                            if (!album.tidalId) {
                                console.log(`Warnung: Keine Tidal ID f√ºr ${album.album} - ${album.artist}`);
                            }
                            
                            processed++;
                            
                            // Update progress
                            this.showLoading(`Lade Album-Daten von Last.fm...`, processed, total);
                            
                            console.log(`Geladen (${processed}/${total}): ${album.album} - ${album.artist}`);
                        }));
                        
                        // Small delay between batches to respect rate limits
                        if (i + batchSize < this.albums.length) {
                            await this.sleep(delayBetweenBatches);
                        }
                    }

                    console.log('Alle Daten geladen, rendere jetzt...');
                    
                    // Save to localStorage
                    this.saveToStorage();
                    
                    // Now render grouped by genre
                    this.renderAlbumsByGenre();
                } catch (error) {
                    console.error('Fehler beim Laden der Daten:', error);
                    this.showError('Fehler beim Laden der Daten: ' + error.message);
                }
            }

            async fetchAlbumCover(albumName, artistName) {
                try {
                    // Call Netlify Function instead of Last.fm directly
                    const response = await fetch('/.netlify/functions/lastfm', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            method: 'album.getinfo',
                            params: {
                                artist: artistName,
                                album: albumName
                            }
                        })
                    });

                    const data = await response.json();

                    if (data.album && data.album.image) {
                        const images = data.album.image;
                        const largeImage = images.find(img => img.size === 'extralarge') || 
                                         images.find(img => img.size === 'large') ||
                                         images[images.length - 1];
                        
                        if (largeImage && largeImage['#text']) {
                            return largeImage['#text'];
                        }
                    }
                    return null;
                } catch (error) {
                    console.error('Error loading cover:', error);
                    return null;
                }
            }

            async fetchTidalAlbumId(albumName, artistName) {
                // First, try direct Tidal search API
                try {
                    const searchQuery = encodeURIComponent(`${artistName} ${albumName}`);
                    const tidalResponse = await fetch(`https://api.tidal.com/v1/search/albums?query=${searchQuery}&limit=5&countryCode=US`);
                    
                    if (tidalResponse.ok) {
                        const tidalData = await tidalResponse.json();
                        if (tidalData.items && tidalData.items.length > 0) {
                            // Find best match
                            const bestMatch = tidalData.items.find(item => {
                                const matchAlbum = item.title.toLowerCase().includes(albumName.toLowerCase()) ||
                                                  albumName.toLowerCase().includes(item.title.toLowerCase());
                                const matchArtist = item.artist?.name?.toLowerCase().includes(artistName.toLowerCase()) ||
                                                   artistName.toLowerCase().includes(item.artist?.name?.toLowerCase());
                                return matchAlbum && matchArtist;
                            }) || tidalData.items[0]; // Fallback to first result
                            
                            if (bestMatch && bestMatch.id) {
                                console.log(`Tidal ID via Tidal API gefunden f√ºr ${albumName}: ${bestMatch.id}`);
                                return bestMatch.id.toString();
                            }
                        }
                    }
                } catch (error) {
                    console.log('Tidal API nicht verf√ºgbar, versuche MusicBrainz:', error.message);
                }

                // Fallback to MusicBrainz
                try {
                    const mbQuery = encodeURIComponent(`${albumName} AND artist:${artistName}`);
                    const mbResponse = await fetch(`https://musicbrainz.org/ws/2/release/?query=${mbQuery}&fmt=json&limit=5`);
                    const mbData = await mbResponse.json();

                    if (mbData.releases && mbData.releases.length > 0) {
                        // Check first few releases for external URLs
                        for (const release of mbData.releases.slice(0, 3)) {
                            if (release.id) {
                                const urlResponse = await fetch(`https://musicbrainz.org/ws/2/release/${release.id}?inc=url-rels&fmt=json`);
                                const urlData = await urlResponse.json();
                                
                                if (urlData.relations) {
                                    const tidalRelation = urlData.relations.find(rel => 
                                        rel.url && rel.url.resource && rel.url.resource.includes('tidal.com')
                                    );
                                    
                                    if (tidalRelation) {
                                        const match = tidalRelation.url.resource.match(/album[\/:](\d+)/);
                                        if (match) {
                                            console.log(`Tidal ID via MusicBrainz gefunden f√ºr ${albumName}: ${match[1]}`);
                                            return match[1];
                                        }
                                    }
                                }
                                
                                // Small delay between MusicBrainz requests (rate limiting)
                                await this.sleep(300);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error fetching Tidal ID from MusicBrainz:', error);
                }

                return null;
            }

            renderAlbumsByGenre() {
                // Group albums by genre
                const albumsByGenre = {};
                this.albums.forEach(album => {
                    const genre = album.genre || 'Unknown';
                    if (!albumsByGenre[genre]) {
                        albumsByGenre[genre] = [];
                    }
                    albumsByGenre[genre].push(album);
                });

                // Sort albums within each genre: first by artist, then by album
                Object.keys(albumsByGenre).forEach(genre => {
                    albumsByGenre[genre].sort((a, b) => {
                        const artistA = (a.artist || '').toLowerCase();
                        const artistB = (b.artist || '').toLowerCase();
                        
                        if (artistA < artistB) return -1;
                        if (artistA > artistB) return 1;
                        
                        const albumA = (a.album || '').toLowerCase();
                        const albumB = (b.album || '').toLowerCase();
                        
                        if (albumA < albumB) return -1;
                        if (albumA > albumB) return 1;
                        return 0;
                    });
                });

                // Group genres by main category
                const genresByCategory = {};
                Object.keys(albumsByGenre).forEach(genre => {
                    const mainCat = this.getMainCategory(genre);
                    if (!genresByCategory[mainCat]) {
                        genresByCategory[mainCat] = {};
                    }
                    genresByCategory[mainCat][genre] = albumsByGenre[genre];
                });

                // Sort main categories by custom order
                const sortedCategories = Object.keys(genresByCategory).sort((a, b) => {
                    const orderA = this.mainCategories[a]?.order || 999;
                    const orderB = this.mainCategories[b]?.order || 999;
                    return orderA - orderB;
                });
                
                const uniqueArtists = new Set(this.albums.map(album => album.artist)).size;
                const totalGenres = Object.keys(albumsByGenre).length;

                // Select 3 random albums with covers
                const albumsWithCovers = this.albums.filter(album => album.coverUrl);
                const randomAlbums = [];
                if (albumsWithCovers.length >= 3) {
                    const shuffled = [...albumsWithCovers].sort(() => Math.random() - 0.5);
                    randomAlbums.push(...shuffled.slice(0, 3));
                }

                let html = `
                    <div style="text-align: center; margin-bottom: 30px;">
                        <button class="reset-btn" onclick="app.loadNewCSV()">‚Üê Neue CSV laden</button>
                    </div>
                    <div class="stats">
                        <div class="stat-item">
                            <span class="stat-number">${this.albums.length}</span>
                            <span class="stat-label">Alben</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">${uniqueArtists}</span>
                            <span class="stat-label">Musiker:innen</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">${totalGenres}</span>
                            <span class="stat-label">Genres</span>
                        </div>
                    </div>
                `;

                // Add random albums showcase if we have at least 3
                if (randomAlbums.length === 3) {
                    html += `
                        <div style="display: flex; justify-content: center; gap: 12px; margin: 40px auto 50px; flex-wrap: wrap; max-width: 600px; padding: 0 20px;">
                            ${randomAlbums.map(album => {
                                // Build Tidal links same way as renderAlbumCard
                                let tidalDeepLink, tidalWebLink;
                                if (album.tidalId) {
                                    tidalDeepLink = `tidal://play/album/${album.tidalId}`;
                                    tidalWebLink = `https://listen.tidal.com/album/${album.tidalId}`;
                                } else {
                                    const searchQuery = encodeURIComponent(`${album.artist} ${album.album}`);
                                    tidalDeepLink = `tidal://search?q=${searchQuery}`;
                                    tidalWebLink = `https://listen.tidal.com/search?q=${searchQuery}`;
                                }
                                
                                return `
                                    <div style="flex: 1; min-width: 100px; max-width: 180px; cursor: pointer; transition: transform 0.2s ease;" 
                                         onclick="app.openInTidal('${tidalDeepLink.replace(/'/g, "\\'")}', '${tidalWebLink.replace(/'/g, "\\'")}', ${!!album.tidalId}, '${album.tidalId || ''}')"
                                         onmouseover="this.style.transform='translateY(-4px)'" 
                                         onmouseout="this.style.transform='translateY(0)'">
                                        <img src="${album.coverUrl}" 
                                             alt="${this.escapeHtml(album.album)}" 
                                             style="width: 100%; aspect-ratio: 1; object-fit: cover; border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.3);">
                                        <div style="margin-top: 6px; font-size: 0.8rem; font-weight: 500; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${this.escapeHtml(album.album)}</div>
                                        <div style="font-size: 0.7rem; color: var(--text-secondary); text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${this.escapeHtml(album.artist)}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                }

                // Create main category sections
                let globalGenreIndex = 0;
                sortedCategories.forEach((mainCategory, catIndex) => {
                    const genres = genresByCategory[mainCategory];
                    const sortedGenres = Object.keys(genres).sort();
                    
                    // Count total albums in this category
                    const totalAlbums = sortedGenres.reduce((sum, genre) => sum + genres[genre].length, 0);
                    
                    const categoryColor = this.mainCategories[mainCategory]?.color || 'rgba(107, 207, 143, 0.4)';
                    
                    html += `
                        <div class="main-category-section">
                            <div class="main-category-header">
                                <div style="display: flex; align-items: center; gap: 12px;">
                                    <span class="main-category-title">${mainCategory}</span>
                                    <span class="main-category-count">${totalAlbums}</span>
                                </div>
                                <button class="shuffle-btn" onclick="app.shuffleCategory('${mainCategory.replace(/'/g, "\\'")}')" title="Zuf√§lliges Album abspielen">
                                    ‚Üª
                                </button>
                            </div>
                            <div class="main-category-content">
                    `;
                    
                    // Create genre accordions within category
                    sortedGenres.forEach((genre, genreIndex) => {
                        const albums = genres[genre];
                        const genreColor = this.getGenreColor(genre);
                        
                        // Get first 3 album covers for preview
                        const previewCovers = albums.slice(0, 3).map(album => {
                            if (album.coverUrl) {
                                return `<img src="${album.coverUrl}" alt="${this.escapeHtml(album.album)}" class="genre-cover-preview">`;
                            }
                            return '';
                        }).filter(Boolean).join('');
                        
                        // Show shuffle button only if more than 3 albums
                        const shuffleBtn = albums.length > 3 
                            ? `<button class="genre-shuffle-btn" onclick="event.stopPropagation(); app.shuffleGenre('${this.escapeHtml(genre).replace(/'/g, "\\'")}', ${globalGenreIndex})" title="Zuf√§lliges Album abspielen">‚Üª</button>`
                            : '';
                        
                        html += `
                            <div class="genre-section">
                                <div class="genre-header" 
                                     onclick="app.toggleGenre(${globalGenreIndex})" 
                                     style="border-left: 3px solid ${genreColor}">
                                    <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                                        <span class="genre-title">${this.escapeHtml(genre)}</span>
                                        <span class="genre-count">${albums.length}</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <div class="genre-preview-covers">
                                            ${previewCovers}
                                        </div>
                                        ${shuffleBtn}
                                        <span class="genre-icon">‚ñº</span>
                                    </div>
                                </div>
                                <div class="genre-content" id="genre-${globalGenreIndex}">
                                    <div class="albums-grid">
                                        ${albums.map((album, index) => this.renderAlbumCard(album, index)).join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                        globalGenreIndex++;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });

                document.getElementById('app').innerHTML = html;
            }

            toggleGenre(index) {
                const headers = document.querySelectorAll('.genre-header');
                const contents = document.querySelectorAll('.genre-content');
                
                headers[index].classList.toggle('active');
                contents[index].classList.toggle('active');
            }

            shuffleCategory(mainCategory) {
                // Get all genres for this main category
                const categoryData = this.mainCategories[mainCategory];
                if (!categoryData) return;

                // Collect all albums from all genres in this category
                const categoryAlbums = this.albums.filter(album => {
                    const lowerGenre = (album.genre || '').toLowerCase();
                    return categoryData.genres.some(g => lowerGenre.includes(g) || g.includes(lowerGenre));
                });

                if (categoryAlbums.length === 0) {
                    alert('Keine Alben in dieser Kategorie gefunden.');
                    return;
                }

                // Pick random album
                const randomAlbum = categoryAlbums[Math.floor(Math.random() * categoryAlbums.length)];

                // Build Tidal links
                let tidalDeepLink, tidalWebLink;
                if (randomAlbum.tidalId) {
                    tidalDeepLink = `tidal://play/album/${randomAlbum.tidalId}`;
                    tidalWebLink = `https://listen.tidal.com/album/${randomAlbum.tidalId}`;
                } else {
                    const searchQuery = encodeURIComponent(`${randomAlbum.artist} ${randomAlbum.album}`);
                    tidalDeepLink = `tidal://search?q=${searchQuery}`;
                    tidalWebLink = `https://listen.tidal.com/search?q=${searchQuery}`;
                }

                // Open in Tidal
                this.openInTidal(tidalDeepLink, tidalWebLink, !!randomAlbum.tidalId, randomAlbum.tidalId || '');
            }

            shuffleGenre(genreName, genreIndex) {
                // Find all albums with this exact genre
                const genreAlbums = this.albums.filter(album => {
                    return album.genre && album.genre.toLowerCase() === genreName.toLowerCase();
                });

                if (genreAlbums.length === 0) {
                    alert('Keine Alben in diesem Genre gefunden.');
                    return;
                }

                // Pick random album
                const randomAlbum = genreAlbums[Math.floor(Math.random() * genreAlbums.length)];

                // Build Tidal links
                let tidalDeepLink, tidalWebLink;
                if (randomAlbum.tidalId) {
                    tidalDeepLink = `tidal://play/album/${randomAlbum.tidalId}`;
                    tidalWebLink = `https://listen.tidal.com/album/${randomAlbum.tidalId}`;
                } else {
                    const searchQuery = encodeURIComponent(`${randomAlbum.artist} ${randomAlbum.album}`);
                    tidalDeepLink = `tidal://search?q=${searchQuery}`;
                    tidalWebLink = `https://listen.tidal.com/search?q=${searchQuery}`;
                }

                // Open in Tidal
                this.openInTidal(tidalDeepLink, tidalWebLink, !!randomAlbum.tidalId, randomAlbum.tidalId || '');
            }

            loadNewCSV() {
                if (confirm('M√∂chtest du wirklich eine neue CSV laden? Die aktuellen Daten werden √ºberschrieben.')) {
                    this.clearStorage();
                    this.albums = [];
                    this.showUploadScreen();
                }
            }

            openInTidal(deepLink, webLink, hasTidalId, tidalId) {
                console.log('√ñffne Tidal:', deepLink);
                
                if (hasTidalId) {
                    // Try to detect if app opens
                    let appOpened = false;
                    
                    const handleVisibilityChange = () => {
                        if (document.hidden) {
                            appOpened = true;
                            console.log('App wurde ge√∂ffnet');
                        }
                    };
                    
                    const handleBlur = () => {
                        appOpened = true;
                        console.log('App wurde ge√∂ffnet (blur)');
                    };
                    
                    document.addEventListener('visibilitychange', handleVisibilityChange);
                    window.addEventListener('blur', handleBlur);
                    
                    // Try play deep link for mobile app
                    const playLink = `tidal://play/album/${tidalId}`;
                    window.location.href = playLink;
                    
                    // Check after 2 seconds if app opened
                    setTimeout(() => {
                        document.removeEventListener('visibilitychange', handleVisibilityChange);
                        window.removeEventListener('blur', handleBlur);
                        
                        if (!appOpened) {
                            console.log('App nicht installiert, √∂ffne Web Player');
                            window.open(webLink, '_blank');
                        } else {
                            console.log('App ge√∂ffnet, kein Web Player n√∂tig');
                        }
                    }, 2000);
                } else {
                    // No Tidal ID - open search in both app and web
                    let appOpened = false;
                    
                    const handleVisibilityChange = () => {
                        if (document.hidden) appOpened = true;
                    };
                    
                    const handleBlur = () => {
                        appOpened = true;
                    };
                    
                    document.addEventListener('visibilitychange', handleVisibilityChange);
                    window.addEventListener('blur', handleBlur);
                    
                    window.location.href = deepLink;
                    
                    setTimeout(() => {
                        document.removeEventListener('visibilitychange', handleVisibilityChange);
                        window.removeEventListener('blur', handleBlur);
                        
                        if (!appOpened) {
                            window.open(webLink, '_blank');
                        }
                    }, 1500);
                }
            }

            renderAlbumCard(album, index) {
                const colors = [
                    'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                    'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                ];
                
                const coverStyle = album.coverUrl 
                    ? `src="${album.coverUrl}"` 
                    : `style="background: ${colors[index % colors.length]}"`;

                // Use Tidal ID if available, otherwise fall back to search
                let tidalDeepLink, tidalWebLink;
                if (album.tidalId) {
                    // Try play action first, fallback to regular album link
                    tidalDeepLink = `tidal://play/album/${album.tidalId}`;
                    tidalWebLink = `https://listen.tidal.com/album/${album.tidalId}`;
                } else {
                    const searchQuery = encodeURIComponent(`${album.artist} ${album.album}`);
                    tidalDeepLink = `tidal://search?q=${searchQuery}`;
                    tidalWebLink = `https://listen.tidal.com/search?q=${searchQuery}`;
                }

                return `
                    <div class="album-card" onclick="app.openInTidal('${tidalDeepLink.replace(/'/g, "\\'")}', '${tidalWebLink.replace(/'/g, "\\'")}', ${!!album.tidalId}, '${album.tidalId || ''}')">
                        <img class="album-cover" ${coverStyle} alt="${this.escapeHtml(album.album || 'Unknown Album')}" loading="lazy">
                        <div class="album-info">
                            <div class="album-title">${this.escapeHtml(album.album || 'Unknown Album')}</div>
                            <div class="album-artist">${this.escapeHtml(album.artist || 'Unknown Artist')}</div>
                            <span class="album-genre">${this.escapeHtml(album.genre || 'Unknown')}</span>
                        </div>
                    </div>
                `;
            }

            async fetchGenreFromLastFM(artist) {
                if (this.genreCache.has(artist)) {
                    return this.genreCache.get(artist);
                }

                try {
                    // Call Netlify Function instead of Last.fm directly
                    const response = await fetch('/.netlify/functions/lastfm', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            method: 'artist.gettoptags',
                            params: {
                                artist: artist
                            }
                        })
                    });

                    const data = await response.json();

                    let genre = 'Unknown';
                    if (data.toptags && data.toptags.tag && data.toptags.tag.length > 0) {
                        // Filter out non-genre tags (nationalities, decades, etc.)
                        const blacklist = [
                            // Nationalities
                            'french', 'german', 'british', 'american', 'canadian', 'australian',
                            'japanese', 'korean', 'swedish', 'norwegian', 'finnish', 'danish', 'kenya',
                            'italian', 'spanish', 'dutch', 'belgian', 'austrian', 'swiss',
                            'irish', 'scottish', 'welsh', 'icelandic', 'portuguese', 'austria', 'bayrisch', 'pakistan', 'peru',
                            'swedish', 'usa', 'ukrainian', 'ukranian',
                            // Cities/Places
                            'london', 'berlin', 'paris', 'new york', 'los angeles', 'tokyo',
                            'nyc', 'la', 'uk', 'usa', 'europe',
                            // Decades
                            '60s', '70s', '80s', '90s', '2000s', '2010s', '00s', '10s',
                            // Non-descriptive
                            'seen live', 'favorite', 'favorites', 'favourite', 'favourites',
                            'love', 'loved', 'awesome', 'beautiful', 'amazing',
                            // Genders
                            'female', 'male', 'female vocalists', 'male vocalists',
                            'female vocalist', 'male vocalist',
                            // Vague descriptors
                            'melancholic', 'melancholy', 'chill', 'atmospheric', 'cello', 'chillwave',
                            'cumbia', 'cybergrind', 'dischord', 'frenchcore', 'gospel', 'guitar',
                            'horrorcore', 'instrumental', 'mathcore', 'neocrust', 'outsider', 'touhou',
                            'bubblegum bass', 'political', 'new age', 'united states'
                        ];
                        
                        // Find first tag that's not in blacklist
                        const validTag = data.toptags.tag.find(tag => {
                            const tagName = tag.name.toLowerCase().trim();
                            return !blacklist.includes(tagName);
                        });
                        
                        if (validTag) {
                            const originalGenre = validTag.name;
                            genre = this.mapGenre(originalGenre);
                            console.log(`Genre f√ºr ${artist}: ${originalGenre} ‚Üí ${genre}`);
                        } else {
                            // Fallback to first tag if all are blacklisted
                            const originalGenre = data.toptags.tag[0].name;
                            genre = this.mapGenre(originalGenre);
                            console.log(`Genre f√ºr ${artist} (fallback): ${originalGenre} ‚Üí ${genre}`);
                        }
                    }

                    this.genreCache.set(artist, genre);
                    return genre;
                } catch (error) {
                    console.error('Error fetching genre:', error);
                    return 'Unknown';
                }
            }

            showLoading(message = 'Verarbeite CSV-Datei...', current = 0, total = 0) {
                const progressText = (current > 0 && total > 0) 
                    ? `<div style="margin-top: 10px; font-size: 1.2rem; font-weight: 600; color: var(--accent);">${current} / ${total}</div>`
                    : '';
                
                const progressBar = (current > 0 && total > 0)
                    ? `<div style="width: 100%; max-width: 300px; height: 4px; background: var(--bg-card); border-radius: 2px; margin: 20px auto 0; overflow: hidden;">
                        <div style="height: 100%; background: var(--accent); width: ${(current/total*100)}%; transition: width 0.3s ease;"></div>
                       </div>`
                    : '';
                
                document.getElementById('app').innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>${message}</p>
                        ${progressText}
                        ${progressBar}
                    </div>
                `;
            }

            showError(message) {
                document.getElementById('app').innerHTML = `
                    <div class="error">
                        <strong>Fehler:</strong> ${message}
                    </div>
                    <div class="upload-container">
                        <button class="upload-btn" onclick="app.init()">
                            Erneut versuchen
                        </button>
                    </div>
                `;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize app
        const app = new AlbumLibraryApp();
        app.init();

        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('[PWA] Service Worker registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('[PWA] Service Worker registration failed:', error);
                    });
            });
        }

        // PWA Install Prompt
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            console.log('[PWA] Install prompt available');
            
            // Show install button in app (if you want to add one later)
            // For now, users can install via browser menu
        });

        window.addEventListener('appinstalled', () => {
            console.log('[PWA] App was installed');
            deferredPrompt = null;
        });
    </script>
</body>
</html>
